<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://notes.bencuan.me/cs61b/oop/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/cs61b/oop/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://notes.bencuan.me/cs61b/oop/inheritance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/inheritance/</guid><description>What is inheritance? # Essentially, it&amp;rsquo;s a way of putting similar objects together to generalize behavior. Inheritance is best used with relating subtypes to larger categories. For example, an :tangerine:orange is a fruit (so it&amp;rsquo;s a subtype of fruit).
Let&amp;rsquo;s say that a supermarket named Jrader Toe&amp;rsquo;s asks us to simulate fruits for them in an online system. We could do it like this:
Now, every fruit would need some of the same properties- like cost, weight, and name!</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/access-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/access-control/</guid><description>What is Access Control? # In Java, we can specify the level of access certain variables and methods have. With this power, we can show or hide these variables to other classes and references on demand!
There are 4 modifier levels that get progressively more open:
Private: Only this class can see it. Package Protected (the default level): All classes in the same package can see it. Protected: Subclasses (that inherit from the parent) can also see it.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/dynamic-method-selection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/dynamic-method-selection/</guid><description>Dynamic Method Selection # [!warning] Content Note
This is a very tricky topic. Make sure you are comfortable with inheritance and access controlbefore proceeding!
Inheritance is great and all, but it does have some issues. One of the biggest issues lies in overriding: if two methods have exactly the same name and signature, which one do we call?
In a standard use case, this is a pretty simple answer: whichever one is in the class we want!</description></item><item><title>Java Objects</title><link>https://notes.bencuan.me/cs61b/oop/objects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/objects/</guid><description>There are two main categories of objects in Java: Primitive Types and Reference Types. This page will give a brief overview of both, and close off with some info about the mystical Object class.
Primitive Types # Primitive types are built in to Java and have fixed memory sizes. Different types require different amounts of memory.
If you remember environment diagrams, you may recall that some variables are put straight into the boxes, while others have an arrow pointing to them.</description></item><item><title>Generic Types</title><link>https://notes.bencuan.me/cs61b/oop/generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/generics/</guid><description>Sometimes, we want things to support any type, including user defined types that we don&amp;rsquo;t know about! For example, it would make sense that we don&amp;rsquo;t care what type we make a List out of, since it&amp;rsquo;s just a whole bunch of objects put together.
The Java solution is generics! Generic types are denoted by a &amp;lt;&amp;gt; and can be appended to methods and classes. Here&amp;rsquo;s an example with classes:</description></item></channel></rss>