<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/cs61b/abstract-data-types/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/graphs/</guid><description>Introduction # Graphs are simply a collection of vertices connected by edges. They&amp;rsquo;re very similar to trees, but are much more versatile and don&amp;rsquo;t require hierarchical relationships like trees do.
For most purposes, we will be working with simple graphs that follow two rules:
There are no loops (a connection of a node to itself). There are no parallel edges (two edges that connect the same two vertices).</description></item><item><title>Hashing and Hash Tables</title><link>https://notes.bencuan.me/cs61b/abstract-data-types/hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/hashing/</guid><description>Data Indexed Sets: Introduction # So far, we&amp;rsquo;ve explored a whole bunch of ways we can store items, but they aren&amp;rsquo;t really optimized for general searching. What if we could get searching in $\Theta(1)$ time??? Wouldn&amp;rsquo;t that be nice!
Let&amp;rsquo;s try something: putting all of our data in a massive array. Let&amp;rsquo;s say that we know all our data falls into the range from 0 to 10,000 and make an array of 10,000 length to hold stuff.</description></item><item><title>Union Find (Disjoint Sets)</title><link>https://notes.bencuan.me/cs61b/abstract-data-types/union-find-disjoint-sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/union-find-disjoint-sets/</guid><description>Union Find (Disjoint Sets) # {% hint style=&amp;ldquo;info&amp;rdquo; %} This is not a complete entry, because I feel like existing course materials already cover this in an extremely intuitive manner.
See lab 14 for an guide on how to implement your own Union Find structure! {% endhint %}
The Union Find data structure is a way of representing a bunch of nodes that are connected to each other in subsets.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/comparables-and-comparators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/comparables-and-comparators/</guid><description>What is it? # A Comparable is a generic type that allows standardized comparisons between objects.
In other words, anything that has a compareTo() method can be a Comparable!
Many Java libraries already use Comparable without you knowing! Some of the more well-known ones are Collection and String.
CompareTo can&amp;rsquo;t return anything you want! # There are some very specific properties CompareTo needs to have! Usually, we take them for granted but might forget about them when making our own.</description></item></channel></rss>