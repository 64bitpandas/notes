<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/cs61b/algorithms/shortest-paths/index.xml" rel="self" type="application/rss+xml"/><item><title>Dijkstra's Algorithm</title><link>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/dijkstras-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/dijkstras-algorithm/</guid><description>[!info] Content Note
Before continuing, make sure you&amp;rsquo;re comfortable with Graphs, Stacks and Queues, and Shortest Paths.
One sentence overview # Visit vertices in order of best-known distance from source; on visit, relax every edge from the visited vertex.
Detailed Breakdown # Djikstras uses a PriorityQueue to maintain the path with lowest cost from the starting node to every other node, an edgeTo array to keep track of the best known predecessor for each vertex, and a distTo array to keep track of the best known distance from the source vertex to every other vertex.</description></item><item><title>A* Search</title><link>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/a-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/a-search/</guid><description>[!info] Content Note
In order to understand A*, you&amp;rsquo;ll need to be comfortable Dijkstra&amp;rsquo;s Algorithm first!
A* Algorithm # The A* Search Algorithm is incredibly similar to Dijkstra&amp;rsquo;s Algorithm with one addition: a heuristic function.
This heuristic function calculates weights of a path from a vertex to a goal vertex. This way, we can help bias our algorithm in the right direction so that it doesnâ€™t make a bunch of bad moves.</description></item></channel></rss>