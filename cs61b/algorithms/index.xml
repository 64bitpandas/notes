<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://notes.bencuan.me/cs61b/algorithms/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/cs61b/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Sorting</title><link>https://notes.bencuan.me/cs61b/algorithms/sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/sorting/</guid><description>[!important] Sorting Guide
For more information about specific sorting algorithms covered in 61B, see my guide on sorting that covers all of the sorts in far greater detail ðŸ™‚
Why sort? # It makes searching for a specific value much faster (e.g. binary search). Typically, searching through an unsorted list requires a full scan ($\Theta(N)$â€‹ runtime). It&amp;rsquo;s easy to see if two items in list are equal: just compare to see if any neighboring values are the same.</description></item><item><title>Minimax Algorithm</title><link>https://notes.bencuan.me/cs61b/algorithms/minimax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimax/</guid><description>Game Trees # The Minimax algorithm is often used for making AI&amp;rsquo;s for turn-based games. It relies on the use of a type of game tree, which maps out all of the possible moves that players can make.
In the tree, there are two types of nodes: maximizing nodes and minimizing nodes. The max-nodes represent you- you want to make your position as advantageous as possible (maximizing your score). The min-nodes represent your opponent- they want to make you do as poorly as possible (minimizing your score).</description></item></channel></rss>