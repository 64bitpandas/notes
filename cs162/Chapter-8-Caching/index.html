<!doctype html><html lang=en dir=ltr><head><meta property="og:title" content="Chapter 8: Caching"><meta property="og:description" content="Introduction #  At this point, we&rsquo;ve solved nearly all of the problems with base and bound memory translation. But there is one major problem left‚Äî all of this additional complexity adds lots of memory accesses, which might make things very inefficient! This is where caching comes in.
Since programs only care about a very small subset of the total information available, if we identify this subset and place it into more local memory, then we can efficiently perform most memory accesses."><meta property="og:type" content="article"><meta property="og:url" content="https://notes.bencuan.me/cs162/Chapter-8-Caching/"><meta property="article:section" content="cs162"><meta property="article:modified_time" content="2023-01-11T00:22:58+00:00"><meta property="og:site_name" content="üóíÔ∏è Ben's Notes"><title>Chapter 8: Caching | üóíÔ∏è Ben's Notes</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.9571c7adb6029c898bf9b839bbb08bbb02cf98ea0b2512213e6dad0a0b116159.css integrity="sha256-lXHHrbYCnImL+bg5u7CLuwLPmOoLJRIhPm2tCgsRYVk=" crossorigin=anonymous><meta charset=utf-8><meta name=description content="Introduction #  At this point, we&rsquo;ve solved nearly all of the problems with base and bound memory translation. But there is one major problem left‚Äî all of this additional complexity adds lots of memory accesses, which might make things very inefficient! This is where caching comes in.
Since programs only care about a very small subset of the total information available, if we identify this subset and place it into more local memory, then we can efficiently perform most memory accesses."><title>Chapter 8: Caching</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://notes.bencuan.me//favicon.png><link href=https://notes.bencuan.me/styles.e08ceb33360cec132feb69cfb982e2a4.min.css rel=stylesheet><link href=https://notes.bencuan.me/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://notes.bencuan.me/quartz/js/darkmode.9d3e1c1ebec61822893ee54cff5423d0.min.js></script>
<script src=https://notes.bencuan.me/quartz/js/util.c69e233dc1cc331a30b0f670e657b425.min.js></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://notes.bencuan.me/quartz/js/popover.f03552ccb84d99ca615d1cfb9abde59e.min.js></script>
<script defer src=https://notes.bencuan.me/quartz/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://notes.bencuan.me/quartz/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://notes.bencuan.me/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://notes.bencuan.me/",fetchData=Promise.all([fetch("https://notes.bencuan.me/indices/linkIndex.a38e668257a4df69715bea19840dd6eb.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://notes.bencuan.me/indices/contentIndex.ecea8fc8d63c8021a1a3e41cf7188bc3.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addCollapsibleCallouts(),initPopover("https://notes.bencuan.me",!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!0;drawGraph("https://notes.bencuan.me",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var i=document.getElementsByClassName("mermaid");i.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'‚Äô':"'"},throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://notes.bencuan.me/quartz/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><header class=book-header><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h1 id=page-title><a href=https://notes.bencuan.me/>üóíÔ∏è Ben's Notes</a></h1><div class=spacer></div><div id=search-icon class=quartz-search><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control><main class=flex><aside class=book-menu><div class=book-menu-content><nav><div class=menu-search><div id=search-icon class=quartz-search><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div></div><ul><li><input type=checkbox id=section-da99de074169576d9f77860d41691a68 class=toggle>
<label for=section-da99de074169576d9f77860d41691a68 class="flex justify-between"><a href=/cs61b/ class=book-collapse-toggle>CS 61B</a></label><ul><li><span class=book-menu-title>Object Oriented Programming</span><ul><li><a href=/cs61b/oop/inheritance/>Inheritance</a></li><li><a href=/cs61b/oop/access-control/>Access Control</a></li><li><a href=/cs61b/oop/dynamic-method-selection/>Dynamic Method Selection</a></li><li><a href=/cs61b/oop/objects/>Java Objects</a></li><li><a href=/cs61b/oop/generics/>Generic Types</a></li></ul></li><li><span class=book-menu-title>Asymptotics</span><ul><li><a href=/cs61b/asymptotics/asymptotics/>Asymptotic Analysis Basics</a></li><li><a href=/cs61b/asymptotics/amortization/>Amortization</a></li><li><a href=/cs61b/asymptotics/asymptotics-practice/>Asymptotics Practice</a></li></ul></li><li><span class=book-menu-title>Abstract Data Types</span><ul><li><input type=checkbox id=section-70dba6a254ce0b2bcdb77dd58dbf6cdc class=toggle>
<label for=section-70dba6a254ce0b2bcdb77dd58dbf6cdc class="flex justify-between"><a href=/cs61b/abstract-data-types/collections/ class=book-collapse-toggle>Collections</a></label><ul><li><a href=/cs61b/abstract-data-types/collections/arrays/>Arrays</a></li><li><a href=/cs61b/abstract-data-types/collections/linked-lists/>Linked Lists</a></li><li><a href=/cs61b/abstract-data-types/collections/sets/>Sets</a></li><li><a href=/cs61b/abstract-data-types/collections/stacks-and-queues/>Stacks and Queues</a></li></ul></li><li><input type=checkbox id=section-5eb2d5b415a82a45c7861774887e844b class=toggle>
<label for=section-5eb2d5b415a82a45c7861774887e844b class="flex justify-between"><a href=/cs61b/abstract-data-types/binary-trees/ class=book-collapse-toggle>Binary Trees</a></label><ul><li><a href=/cs61b/abstract-data-types/binary-trees/balanced-search-structures/>Balanced Search Structures</a></li><li><a href=/cs61b/abstract-data-types/binary-trees/heaps/>Heaps</a></li><li><a href=/cs61b/abstract-data-types/binary-trees/tries/>Tries</a></li></ul></li><li><a href=/cs61b/abstract-data-types/graphs/>Graphs</a></li><li><a href=/cs61b/abstract-data-types/hashing/>Hashing and Hash Tables</a></li><li><a href=/cs61b/abstract-data-types/union-find-disjoint-sets/>Union Find (Disjoint Sets)</a></li><li><a href=/cs61b/abstract-data-types/comparables-and-comparators/>Comparables and Comparators</a></li></ul></li><li><span class=book-menu-title>Algorithms</span><ul><li><input type=checkbox id=section-26838f44377a3dfc0925929b8b82de69 class=toggle>
<label for=section-26838f44377a3dfc0925929b8b82de69 class="flex justify-between"><a href=/cs61b/algorithms/searching/ class=book-collapse-toggle>Searching</a></label><ul><li><a href=/cs61b/algorithms/searching/binary-search/>Binary Search</a></li><li><a href=/cs61b/algorithms/searching/breadth-first-search-bfs/>Breadth First Search (DFS)</a></li><li><a href=/cs61b/algorithms/searching/depth-first-search-dfs/>Depth First Search (DFS)</a></li></ul></li><li><input type=checkbox id=section-fd5238a874e42ff4e1ab0e65c20a9824 class=toggle>
<label for=section-fd5238a874e42ff4e1ab0e65c20a9824 class="flex justify-between"><a href=/cs61b/algorithms/shortest-paths/ class=book-collapse-toggle>Shortest Paths</a></label><ul><li><a href=/cs61b/algorithms/shortest-paths/dijkstras-algorithm/>Dijkstra's Algorithm</a></li><li><a href=/cs61b/algorithms/shortest-paths/a-search/>A* Search</a></li></ul></li><li><input type=checkbox id=section-434cf8cf80558e0886666bff24d740d1 class=toggle>
<label for=section-434cf8cf80558e0886666bff24d740d1 class="flex justify-between"><a href=/cs61b/algorithms/minimum-spanning-trees/ class=book-collapse-toggle>Minimum Spanning Trees</a></label><ul><li><a href=/cs61b/algorithms/minimum-spanning-trees/kruskals-algorithm/>Kruskal's Algorithm</a></li><li><a href=/cs61b/algorithms/minimum-spanning-trees/prims-algorithm/>Prim's Algorithm</a></li></ul></li><li><a href=/cs61b/algorithms/sorting/>Sorting</a></li><li><a href=/cs61b/algorithms/minimax/>Minimax Algorithm</a></li></ul></li><li><span class=book-menu-title>Misc. Topics</span><ul><li><a href=/cs61b/misc-topics/exceptions/>Exceptions</a></li><li><a href=/cs61b/misc-topics/modular-arithmetic/>Modular Arithmetic</a></li><li><a href=/cs61b/misc-topics/more-resources/>More Resources</a></li></ul></li></ul></li><li><input type=checkbox id=section-ee67b82ee54e976a9f81e3e41661ae13 class=toggle>
<label for=section-ee67b82ee54e976a9f81e3e41661ae13 class="flex justify-between"><a href=/cs70/ class=book-collapse-toggle>CS 70</a></label><ul><li><a href=/cs70/latex-reference/>LaTeX Reference</a></li><li><span class=book-menu-title>Discrete Math</span><ul><li><a href=/cs70/discrete-math/overview/>Discrete Math Overview</a></li><li><a href=/cs70/discrete-math/propositional-logic/>Propositional Logic</a></li><li><a href=/cs70/discrete-math/proofs/>Proofs</a></li><li><a href=/cs70/discrete-math/stable-matching/>Stable Matching</a></li><li><a href=/cs70/discrete-math/graphs/>Graphs</a></li><li><a href=/cs70/discrete-math/modular-arithmetic/>Modular Arithmetic</a></li><li><a href=/cs70/discrete-math/rsa-cryptography/>RSA Cryptography</a></li><li><a href=/cs70/discrete-math/polynomials/>Polynomials</a></li><li><a href=/cs70/discrete-math/countability/>Countability</a></li><li><a href=/cs70/discrete-math/computability/>Computability</a></li></ul></li><li><span class=book-menu-title>Probability</span><ul><li><a href=/cs70/probability/probability-overview/>Probability Overview</a></li><li><a href=/cs70/probability/counting/>Counting</a></li><li><a href=/cs70/probability/discrete-probability/>Discrete Probability</a></li><li><a href=/cs70/probability/hashing-and-the-union-bound/>Hashing and the Union Bound</a></li><li><a href=/cs70/probability/expectation-and-variance/>Expectation and Variance</a></li><li><a href=/cs70/probability/concentration-inequalities/>Concentration Inequalities</a></li><li><a href=/cs70/probability/continuous-probability/>Continuous Probability</a></li><li><a href=/cs70/probability/markov-chains/>Markov Chains</a></li><li><a href=/cs70/probability/the-beta-family/>The Beta Family</a></li><li><a href=/cs70/probability/conditional-expectation-and-variance/>Conditional Expectation and Variance</a></li></ul></li></ul></li><li><input type=checkbox id=section-6d80b867b0e7b10bf4afdb6cb30147b7 class=toggle>
<label for=section-6d80b867b0e7b10bf4afdb6cb30147b7 class="flex justify-between"><a href=/cs186/ class=book-collapse-toggle>CS 186</a></label><ul><li><a href=/cs186/io/>What is an I/O and why should I care?</a></li><li><a href=/cs186/00-SQL-Basics/>SQL Basics</a></li><li><a href=/cs186/01-Disks-Buffers-Files/>Disks, Buffers, and Files</a></li><li><a href=/cs186/02-B+-Trees/>B+ Trees</a></li><li><a href=/cs186/03-Buffer-Management/>Buffer Management</a></li><li><a href=/cs186/04-Sorting-and-Hashing/>Sorting and Hashing</a></li><li><a href=/cs186/05-Iterators-and-Joins/>Iterators and Joins</a></li><li><a href=/cs186/06-Relational-Algebra/>Relational Algebra</a></li><li><a href=/cs186/07-Query-Optimization/>Query Optimization</a></li><li><a href=/cs186/08-Transactions/>Transactions and ACID</a></li><li><a href=/cs186/09-Parallel-Query-Processing/>Parallel Query Processing</a></li><li><a href=/cs186/10-Recovery/>Recovery</a></li><li><a href=/cs186/11-Distributed-Transactions/>Distributed Transactions</a></li><li><a href=/cs186/12-ER-Diagrams/>E-R Diagrams</a></li></ul></li><li><input type=checkbox id=section-a5f138e4453c6deda66a767c13d8a673 class=toggle checked>
<label for=section-a5f138e4453c6deda66a767c13d8a673 class="flex justify-between"><a href=/cs162/ class=book-collapse-toggle>CS 162</a></label><ul><li><a href=/cs162/Chapter-1-OS-Basics/>Chapter 1: OS Basics</a></li><li><a href=/cs162/Chapter-2-Processes/>Chapter 2: Processes</a></li><li><a href=/cs162/Chapter-3-Threads/>Chapter 3: Threads</a></li><li><a href=/cs162/Chapter-4-I-O/>Chapter 4: I/O</a></li><li><a href=/cs162/Chapter-5-Synchronization/>Chapter 5: Synchronization</a></li><li><a href=/cs162/Chapter-6-Scheduling/>Chapter 6: S cheduling</a></li><li><a href=/cs162/Chapter-7-Address-Translation/>Chapter 7: Address Translation</a></li><li><a href=/cs162/Chapter-8-Caching/ class=active>Chapter 8: Caching</a></li><li><a href=/cs162/Chapter-9-File-Systems/>Chapter 9: File Systems</a></li><li><a href=/cs162/Appendix-A-GDB-foobars/>GDB Reference</a></li></ul></li><li><input type=checkbox id=section-d6662b440d117f766a2c3bdd162dce8f class=toggle>
<label for=section-d6662b440d117f766a2c3bdd162dce8f class="flex justify-between"><a href=/cs168/ class=book-collapse-toggle>CS 168</a></label><ul><li><a href=/cs168/intro-to-the-internet/>Intro to the Internet</a></li><li><a href=/cs168/cli/>CLI Tools</a></li><li><a href=/cs168/intradomain-routing/>Introduction to Routing</a></li><li><a href=/cs168/measuring-link-performance/>Measuring Link Performance</a></li><li><a href=/cs168/resource-sharing-packet-and-circuit-switching/>Resource Sharing</a></li><li><a href=/cs168/internet-organization-and-layers/>Internet Organization</a></li><li><a href=/cs168/sockets-and-ports/>Sockets and Ports</a></li><li><a href=/cs168/addressing-ip/>Addressing</a></li><li><a href=/cs168/interdomain-routing-bgp/>Interdomain Routing (BGP)</a></li><li><a href=/cs168/TCP/>TCP</a></li><li><a href=/cs168/reliability/>Reliability</a></li><li><a href=/cs168/congestion-control/>Congestion Control</a></li><li><a href=/cs168/dns/>DNS</a></li><li><a href=/cs168/web/>Web</a></li><li><a href=/cs168/ethernet/>Ethernet</a></li><li><a href=/cs168/end-to-end-operation/>End to End Operation</a></li><li><a href=/cs168/final-review/>Final Review</a></li></ul></li><li><input type=checkbox id=section-0ab56f4e325729fc5ee23c1204712a3e class=toggle>
<label for=section-0ab56f4e325729fc5ee23c1204712a3e class="flex justify-between"><a role=button class=book-collapse-toggle>CS 61A</a></label><ul><li><a href=/cs61a/introduction/>Overview</a></li><li><a href=/cs61a/resources/>Resources</a></li><li><a href=/cs61a/midterm-tips/>Midterm Tips</a></li></ul></li><li><input type=checkbox id=section-7a47eedeadc37bd22193fe5cd002031e class=toggle>
<label for=section-7a47eedeadc37bd22193fe5cd002031e class="flex justify-between"><a href=/data102/ class=book-collapse-toggle>Data 102</a></label><ul><li><a href=/data102/binary-decision-making/>Binary Decision Making</a></li><li><a href=/data102/hypothesis-testing/>Hypothesis Testing</a></li><li><a href=/data102/decision-theory/>Decision Theory</a></li><li><a href=/data102/parameter-estimation/>Parameter Estimation</a></li><li><a href=/data102/sampling/>Sampling</a></li><li><a href=/data102/regression-and-glms/>Regression and GLMs</a></li><li><a href=/data102/nonparametric-methods/>Nonparametric Methods</a></li><li><a href=/data102/interpretability/>Interpretability</a></li><li><a href=/data102/causality/>Causality</a></li><li><a href=/data102/concentration-inequalities/>Concentration Inequalities</a></li><li><a href=/data102/bandits/>Bandits</a></li><li><a href=/data102/Markov-Decision-Processes/>Markov Decision Processes</a></li><li><a href=/data102/Reinforcement-Learning/>Reinforcement Learning</a></li></ul></li></ul><ul><li><a href=/contributing target=_blank rel=noopener>Contribute</a></li><li><a href=https://github.com/64bitpandas/notes/issues target=_blank rel=noopener>Feedback</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class="book-page container"><article class=markdown><h1 class=title>Chapter 8: Caching</h1><h1 id=introduction>Introduction
<a class=anchor href=#introduction>#</a></h1><p>At this point, we&rsquo;ve solved nearly all of the problems with base and bound memory translation. But there is one major problem left‚Äî all of this additional complexity adds lots of memory accesses, which might make things very inefficient! This is where <strong>caching</strong> comes in.</p><p>Since programs only care about a very small subset of the total information available, if we identify this subset and place it into more local memory, then we can efficiently perform most memory accesses.</p><p>Caches give the benefits of speed from the fastest types of memory while still having the capacity of the largest memory. Ideally, caches are implemented such that they are invisible to programmers: they will automatically move memory between locations.</p><h1 id=cache-terminology>Cache Terminology
<a class=anchor href=#cache-terminology>#</a></h1><h2 id=basic-anatomy>Basic Anatomy
<a class=anchor href=#basic-anatomy>#</a></h2><p>Caches have <strong>tags</strong> (addresses) and <strong>blocks</strong> (aligned words that store information).</p><p>In order to simplify the comparison process (so that we don&rsquo;t need to check every tag to see if we have a hit or miss), we can split the cache into <strong>sets</strong>. So we only need to compare a tag to a particular set in order to determine if we have a hit or miss.</p><p><a class="internal-link broken">Untitled 3.png</a></p><p>A <strong>valid bit</strong> is flipped if a particular entry is valid. If the valid bit is not on, then we should treat an access like a cache miss.</p><p>A <strong>cache flush</strong> invalidates all entries.</p><p>The <strong>cache capacity</strong> is the total number of bytes in the cache.</p><p>A <strong>cache line</strong>, other wise known as a <strong>cache block,</strong> is a single entry in the cache.</p><p>The <strong>block size</strong> is the number of bytes in each cache line/block.</p><p>We can calculate the <strong>number of cache lines</strong> by dividing the cache capacity by the block size.</p><p><strong>Eviction</strong> is the process of removing an entry from the cache.</p><h2 id=locality>Locality
<a class=anchor href=#locality>#</a></h2><p>The primary purpose of caches is to benefit from <strong>locality</strong> of information, which allows data to be accessed faster in common patterns.</p><p>There are two different types of locality:</p><ul><li><strong>Temporal Locality:</strong> locality in time. If a memory location is referenced, then chances are it might be needed again soon and so we should keep it around.</li><li><strong>Spatial Locality:</strong> locality in space. If a memory location is referenced, then chances are the addresses close to that will be needed soon and should be saved to faster memory.</li></ul><h2 id=hits-and-misses>Hits and Misses
<a class=anchor href=#hits-and-misses>#</a></h2><p>A <strong>cache hit</strong> occurs when the memory address we&rsquo;re looking for is actually stored in the cahce.</p><p>A <strong>cache miss</strong> is when we are looking for information that is in the main memory, but not the cache.</p><ul><li><strong>Compulsory Miss:</strong> cold start; the first time we access a block. These get to be pretty insignificant the more memory you have and the longer you run the program.</li><li><strong>Capacity miss:</strong> The cache cannot contain all of the blocks accessed by the program. These can be avoided by increasing the size of the cache.<ul><li>sizeof(array) > cache size</li></ul></li><li><strong>Conflict miss (collision):</strong> Multiple memory locations map to the same cache set. These could be avoided by increasing the associativity of the cache (these would never happen with a fully associative cache).<ul><li>Related to spatial locality breakdown: when stride * sizeof(element) ‚â• block size. i.e. A block is loaded, but only the first element in the block is accessed before it is overwritten by another block.</li></ul></li><li><strong>Coherence miss:</strong> External processors or devices update a part of memory, making the cached version invalid.</li></ul><h2 id=types-of-caches-associativity>Types of Caches: Associativity
<a class=anchor href=#types-of-caches-associativity>#</a></h2><p>The <strong>associativity</strong> of a cache is the number of places each block is allowed to be in. Having a higher associativity increases the total cache capacity (thus reducing AMAT), but becomes more complex.</p><ul><li><strong>Fully associative cache:</strong> Blocks can go anywhere. This is the most flexible option, but requires a large number of comparators (1 per block).</li><li><strong>Direct mapped cache:</strong> Each block goes into one place, such that each set contains exactly one block. This makes it straightforward to check if a block exists (since there is only one place it can possibly go), but is the least flexible.</li><li><strong>N-way Set Associative:</strong> There are N places for a block, such that each set has N number of blocks. This is a compromise between fully associative (N = # blocks) and direct mapped (N = 1).</li></ul><h2 id=tags-index-offset-the-address>Tags, Index, Offset: The Address
<a class=anchor href=#tags-index-offset-the-address>#</a></h2><p>Addresses in the cache are divided into tag, index, and offset.</p><p><a class="internal-link broken">Untitled 5.png</a></p><h3 id=offset>Offset
<a class=anchor href=#offset>#</a></h3><p>Tells us where data exists in the cache line.</p><p>Containes $\log_2(blocksize)$ number of <em>bytes</em> (not bits) (for example, 64 byte blocks can be represented using 6 offset bits).</p><h3 id=index>Index
<a class=anchor href=#index>#</a></h3><p>Tells us the where in the cache an address might be stored.</p><p>Contains $\log_2$(num cache lines / associativity) number of bits.</p><p>For example, a 4 way associative cache with 512 lines requires 7 index bits.</p><h3 id=tag>Tag
<a class=anchor href=#tag>#</a></h3><p>Determines which memory location in the cache that the data is stored.</p><p>The number of bits in the tag is just the bits remaining (total address bits - index bits - offset bits).</p><p><a class="internal-link broken">Untitled 6.png</a></p><h2 id=total-cache-capacity>Total Cache Capacity
<a class=anchor href=#total-cache-capacity>#</a></h2><p><strong>Total cache capacity</strong> = Associativity $\times$ Number of Sets $\times$ Block Size</p><p><strong>Bytes of memory in cache</strong> = blocks per set $\times$ number of sets $\times$ bytes per block</p><p><strong>Increasing associativity:</strong> Increases hit time, decreases miss rate (less conflict misses), does not change miss penalty</p><p><strong>Increasing number of entries:</strong> increases hit time (reading from larger memory), decreases miss rate (2x drop for every 4x increase in capacity), does not change miss penalty.</p><p><strong>Increasing block size:</strong> does not change hit time, decreases miss rate due to spatial locality but increases conflict misses in the long run, larger miss penalty</p><p><strong>Reducing miss penalty:</strong> Use more cache levels!</p><h2 id=cache-performance>Cache Performance
<a class=anchor href=#cache-performance>#</a></h2><p><strong>Hit Time:</strong> the amount of time needed to return data in a cache. This is usually measured in terms of cycles.</p><p><strong>Miss penalty:</strong> The additional time to return an element if it is not in the cache.</p><p><strong>Miss rate:</strong> The proportion of a program&rsquo;s memory requests that cause a cache miss.</p><p>The main measurement of cache performance is <strong>AMAT</strong> (Average Memory Access Time).</p><p><strong>AMAT = Hit Time + Miss Rate * Miss Penalty</strong></p><p>For example, if a memory access takes 50ns, the cache lookup time is 5ns, and the hit rate is 90%, the AMAT would be:</p><p>$0.9 * 5 + 0.1 (5 + 50)$ which is 10ns.</p><p>We can improve AMAT by:</p><ul><li>Reducing the time to hit in the cache (make it smaller)</li><li>Reduce the miss rate (bigger cache or better programs)</li><li>Reduce the miss penalty (have multiple cache levels)</li></ul><h2 id=write-through-vs-write-back>Write-through vs. Write-back
<a class=anchor href=#write-through-vs-write-back>#</a></h2><p>When store instructions write to memory, we change the values. We need to then change both the cache value and the memory value to make sure that everything remains consistent.</p><p>We can use the <strong>write-through policy</strong> which states that we need to write values to both cache and memory. Since writing to memory is slow, we can instead write to a <strong>write buffer</strong> which stores the desired value until it is done being written.</p><p>The <strong>write-back policy</strong> states that we should write only to cache and then write the cache block back to memory when the block is evicted from the cache. That way, there is only a single write to memory per block, and writes are collected in the cache.</p><ul><li>Using the write-back policy, we include a &ldquo;dirty&rdquo; bit to indicate if a block was written to or not.</li></ul><p>Write through is good because:</p><ul><li>It has simpler control logic.</li><li>There is more predictable timng.</li><li>It&rsquo;s easier to make reliable since there is memory redundancy (both cache and DRAM have new values).</li></ul><p>On the other hand, write-back:</p><ul><li>Is more complex, with variable timing.</li><li>Reduces write traffic since we do fewer writes.</li><li>Sometimes, only cache has data and so cache failure would result in disaster.</li></ul><hr><h1 id=translation-lookaside-buffer-tlb>Translation Lookaside Buffer (TLB)
<a class=anchor href=#translation-lookaside-buffer-tlb>#</a></h1><p>To improve the performance of our address translation scheme from the previous chapter, let&rsquo;s see how we can apply the concept of caches to storing recently used addresses.</p><p>We can store mappings from virtual to physical addresses in a custom cache known as the <strong>translation lookaside buffer.</strong> That way, even if we have a multi-level address translation scheme, stored addresses can be quickly accessed with no further memory lookups required.</p><p><img src=https://notes.bencuan.me/cs162/Chapter%208%20Caching/Untitled.png width=auto alt=Untitled></p><h3 id=thrashing>Thrashing
<a class=anchor href=#thrashing>#</a></h3><p>While great for reducing access times for cache hits, miss times with the TLB are very high because it exists in the critical path, and we would need additional accesses to go around it.</p><p>If the TLB is not big enough, or we otherwise keep evicting entries that are still needed, <strong>thrashing</strong> occurs, where there are continuous conflicts between accesses. To circumvent this, most TLBs are fully associative and have 128 to 512 entries.</p><h3 id=memory-access-walkthrough>Memory Access Walkthrough
<a class=anchor href=#memory-access-walkthrough>#</a></h3><p>When some data needs to be accessed from the disk, the following happens:</p><ol><li>Check the TLB. If the cached translation exists, then we can simply access the physical memory directly.</li><li>Check the page table. If the page exists, then access it directly.</li><li>Otherwise, the entry is invalid or missing and a <strong>page fault</strong> occurs.</li><li>Load the page into memory.</li><li>Update the page table.</li><li>Update the TLB to point to the new page entry.</li></ol><h1 id=demand-paging>Demand Paging
<a class=anchor href=#demand-paging>#</a></h1><p>The final application of caching we&rsquo;ll explore in this chapter is <strong>demand paging.</strong> In addition to storing address translations in a cache, we can also store the data from the disk itself!</p><p>The reason why this is useful is because modern computers typically do not use all of their physical memory. Thus, we can take advantage of the unused portions to speed up otherwise slow disk accesses. In other words, we use physical memory as a cache for the disk.</p><h2 id=demand-paging-mechanisms>Demand Paging Mechanisms
<a class=anchor href=#demand-paging-mechanisms>#</a></h2><p>Here&rsquo;s how demand paging is typically set up, in cache terms:</p><ul><li>The block size is typically 4KB (1 page each).</li><li>The cache is fully associative, since it can arbitrarily map any virtual address to any physical address.</li><li>The cache is write-back, since write-through would defeat the entire purpose of demand paging. This means we need a dirty bit in the cache.</li><li>On a page fault, the following occurs:<ul><li>Choose an old page to replace (by a demand paging policy in the next section).</li><li>If the old page was modified (i.e. dirty bit set), then write the contents back to the disk before evicting.</li><li>Change the old page&rsquo;s page table entry and TLB to be invalid.</li><li>Load the new page into memory.</li><li>Update the page table entry and invalidate the previous TLB entry for that page.</li><li>Continue the current thread. When the thread starts, it will update the TLB.</li></ul></li></ul><h2 id=the-working-set-model>The Working Set Model
<a class=anchor href=#the-working-set-model>#</a></h2><p>Every program has to access a certain amount of memory in its execution. We can call the entire set that needs to be accessed the <strong>working set.</strong> A larger proportion of cache hits generally means that a larger part of the working set is available in the cache.</p><ul><li>The minimum number of entries needed to store the entire working set in the TLB is (working set size)/(page size). For example, if the working set size is 256KB and the page size is 4KB, then 64 entries are required.</li></ul><p>At any point in time, a portion of the demand paging cache (i.e. main memory) is used to store a process. We can call this the <strong>resident set size.</strong></p><ul><li>If the physical memory size is less than the resident set size, then thrashing is likely to occur.</li></ul><h2 id=page-replacement-policies>Page Replacement Policies
<a class=anchor href=#page-replacement-policies>#</a></h2><h3 id=fifo>FIFO
<a class=anchor href=#fifo>#</a></h3><h3 id=random>RANDOM
<a class=anchor href=#random>#</a></h3><h3 id=min>MIN
<a class=anchor href=#min>#</a></h3><h3 id=lru>LRU
<a class=anchor href=#lru>#</a></h3><h3 id=clock>CLOCK
<a class=anchor href=#clock>#</a></h3><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/cs162// data-ctx=Caching data-src=/cs162/ class=internal-link>CS 162</a></li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://notes.bencuan.me/quartz/js/graph.cbd78cfa87df7d3e230d16fc24f06548.js></script></div></div><div id=contact_buttons><footer><p>Made with <a href=https://github.com/64bitpandas/amethyst>Amethyst</a>, ¬© 2023 Ben Cuan</p><ul><li><a href=https://notes.bencuan.me/>Home</a></li><li><a href=https://github.com/64bitpandas/notes/issues>Feedback</a></li><li><a href=https://bencuan.me>Website</a></li></ul></footer></div></article><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#cache-terminology>Cache Terminology</a><ul><li><a href=#basic-anatomy>Basic Anatomy</a></li><li><a href=#locality>Locality</a></li><li><a href=#hits-and-misses>Hits and Misses</a></li><li><a href=#types-of-caches-associativity>Types of Caches: Associativity</a></li><li><a href=#tags-index-offset-the-address>Tags, Index, Offset: The Address</a><ul><li><a href=#offset>Offset</a></li><li><a href=#index>Index</a></li><li><a href=#tag>Tag</a></li></ul></li><li><a href=#total-cache-capacity>Total Cache Capacity</a></li><li><a href=#cache-performance>Cache Performance</a></li><li><a href=#write-through-vs-write-back>Write-through vs. Write-back</a></li></ul></li><li><a href=#translation-lookaside-buffer-tlb>Translation Lookaside Buffer (TLB)</a><ul><li><ul><li><a href=#thrashing>Thrashing</a></li><li><a href=#memory-access-walkthrough>Memory Access Walkthrough</a></li></ul></li></ul></li><li><a href=#demand-paging>Demand Paging</a><ul><li><a href=#demand-paging-mechanisms>Demand Paging Mechanisms</a></li><li><a href=#the-working-set-model>The Working Set Model</a></li><li><a href=#page-replacement-policies>Page Replacement Policies</a><ul><li><a href=#fifo>FIFO</a></li><li><a href=#random>RANDOM</a></li><li><a href=#min>MIN</a></li><li><a href=#lru>LRU</a></li><li><a href=#clock>CLOCK</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>