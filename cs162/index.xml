<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cs162s on</title><link>https://notes.bencuan.me/cs162/</link><description>Recent content in Cs162s on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/cs162/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://notes.bencuan.me/cs162/Appendix-A-GDB-foobars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Appendix-A-GDB-foobars/</guid><description>Appendix A: GDB foobars # Run with args: r &amp;lt;args&amp;gt;
Breakpoint: b &amp;lt;n&amp;gt;
Conditional breakpoint: b &amp;lt;n&amp;gt; if &amp;lt;condition&amp;gt; or condition &amp;lt;n&amp;gt; &amp;lt;condition&amp;gt; on existing
Step into: step or s (si for assembly)
Step over: next or n (for assembly, ni)
See all registers: info registers (can also do info frame, info args, info locals)
View split mode: ctrl+x ctrl+a
Switch between code and assembly: layout asm, layout src. Ctrl+X A to exit split</description></item><item><title/><link>https://notes.bencuan.me/cs162/Appendix-B-Midterm-Reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Appendix-B-Midterm-Reference/</guid><description>Appendix B: Midterm Reference # /* Semaphore */ int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_wait(sem_t *sem); int sem_post(sem_t *sem); /* Lock */ int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr); int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); /* Condition Variable */ int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr); int pthread_cond_signal(pthread_cond_t *cond); int pthread_cond_broadcast(pthread_cond_t *cond); int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); /* Process */ pid_t fork(void); pid_t wait(int *status); pid_t waitpid(pid_t pid, int *status, int options); int execv(const char *path, char *const argv[]); /* Thread */ int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); int pthread_join(pthread_t thread, void **retval); void pthread_exit(void *retval); /* High-Level IO */ FILE *fopen(const char *pathname, const char *mode); int fclose(FILE *stream); size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream); fprintf(FILE * restrict stream, const char * restrict format, .</description></item><item><title/><link>https://notes.bencuan.me/cs162/Chapter-1-OS-Basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-1-OS-Basics/</guid><description>Chapter 1. OS Basics # What is an operating system? # An operating system has three main roles:
Referee: The OS manages protection, isolation, and allocation of resources between processes. Illusionist: The OS provides an abstraction between hardware and user programs that provides an illusion ****of easy-to-access resources such as files and available processors. Glue: The OS provides common services, sharing, authorization, networking, and communication between processes and external devices.</description></item><item><title/><link>https://notes.bencuan.me/cs162/Chapter-2-Processes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-2-Processes/</guid><description>Chapter 2. Processes # The Process Abstraction # A process is an execution environment with restricted rights.
A process consists of:
An address space Thread(s) of control running in that address space System states associated with threads (files, etc) The process abstraction creates a tradeoff between protection and efficiency: communication is easier within processes, but harder between processes.
UNIX Process Management # Creating Processes: fork and exec # Forking # In UNIX-based systems, the primary way to create new processes is to fork an existing process.</description></item><item><title/><link>https://notes.bencuan.me/cs162/Chapter-3-Threads/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-3-Threads/</guid><description>Chapter 3. Threads # The Thread Abstraction # A thread is a single unique context, or unit of concurrency, for execution that fully describes the program state. A thread consists of a program counter (PC), registers, execution flags, and a stack.
All threads in the same process share the same code, data, and file access, but each has its own register state and stack. Certain registers hold the context of the thread (such as the stack pointer, heap pointer, or frame pointer).</description></item><item><title/><link>https://notes.bencuan.me/cs162/Chapter-4-I-O/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-4-I-O/</guid><description>Chapter 4. I/O # UNIX Abstraction: Everything is a File # A file is a named collection of data in a file system. In the POSIX (Portable Operating System Interface for UNIX) standard, every file includes data (a sequence of bytes) and metadata (such as size, modification time, owner, security, and access control).
Files are organized into directories, which are folders containing files and other directories. Directories employ hierarchical naming (/path/to/file.</description></item><item><title/><link>https://notes.bencuan.me/cs162/Chapter-5-Synchronization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-5-Synchronization/</guid><description>Chapter 5. Synchronization # Race Conditions and Locks # If two independent threads need to modify and read the same values, there could be multiple outputs depending on the order that the threads run in. How do we resolve this?
Synchronization deals with coordination among threads and their shared data
Mutual Exclusion: Only one thread does something at one time (excludes the other threads)
Subtype of synchronization Critical Section: code that only one thread can execute at once (consequence of mutual exclusion)</description></item><item><title/><link>https://notes.bencuan.me/cs162/Chapter-6-Scheduling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-6-Scheduling/</guid><description>Chapter 6. Scheduling # Introduction # When multiple tasks need to be done on a single CPU, we need to figure out a way to distribute the work done by the CPU across all of the tasks.
At any point there are running, waiting, and blocked threads. A processor&amp;rsquo;s scheduling policy determines how and when threads transition between these states.
Scheduling Goals # There are three primary goals for an effective scheduling algorithm.</description></item><item><title/><link>https://notes.bencuan.me/cs162/Chapter-7-Address-Translation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-7-Address-Translation/</guid><description>Chapter 7. Address Translation # Introduction # Every modern computer has physical memory inside of it, that might look something like this:
Physical RAM modules typically contain anywhere from 4 to 128GB of memory (well, at the time of writing). However, there are only a few sticks of RAM, and possibly hundreds of processes that need to access them at the same time!
This is where memory management comes in.</description></item><item><title/><link>https://notes.bencuan.me/cs162/Chapter-8-Caching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-8-Caching/</guid><description>Chapter 8. Caching # Introduction # At this point, we&amp;rsquo;ve solved nearly all of the problems with base and bound memory translation. But there is one major problem leftâ€” all of this additional complexity adds lots of memory accesses, which might make things very inefficient! This is where caching comes in.
Since programs only care about a very small subset of the total information available, if we identify this subset and place it into more local memory, then we can efficiently perform most memory accesses.</description></item><item><title/><link>https://notes.bencuan.me/cs162/Chapter-9-File-Systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-9-File-Systems/</guid><description>Chapter 9. File Systems # I/O # Drivers # A computer handles I/O on its end using several mechanisms:
The bus, a common set of communication wires, carries data transfer transactions between devices. A typical modern bus standard is PCI (Peripheral Component Interconnect), which is a parallel bus that can handle one transaction at a time. One major downside to this is that the bus speed must be set to the slowest connected device.</description></item><item><title/><link>https://notes.bencuan.me/cs162/CS162-Index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/CS162-Index/</guid><description>[[Chapter 1 OS Basics]] - What is an OS, kernels, concurrency. [[Chapter 2 Processes]] - The process abstraction, fork/exec/wait/pipe. [[Chapter 3 Threads]] - Fork-join parallelism, multithreading, TCB, race conditions. [[Chapter 4 I O]] - Everything Is A File, streams, file descriptors, pipes, signals, sockets. [[Chapter 5 Synchronization]] - Locks, semaphores, condition variables, atomic operations. [[Chapter 6 Scheduling]] - Scheduling algorithms (FIFO, MLFQS, etc); deadlock. [[Chapter 7 Address Translation]] - Virtual memory, paging, page tables.</description></item></channel></rss>