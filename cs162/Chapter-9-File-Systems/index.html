<!doctype html><html lang=en dir=ltr><head><meta property="og:title" content="Chapter 9: File Systems"><meta property="og:description" content="I/O #  Drivers #   A computer handles I/O on its end using several mechanisms:
 The bus, a common set of communication wires, carries data transfer transactions between devices.  A typical modern bus standard is PCI (Peripheral Component Interconnect), which is a parallel bus that can handle one transaction at a time. One major downside to this is that the bus speed must be set to the slowest connected device."><meta property="og:type" content="article"><meta property="og:url" content="https://notes.bencuan.me/cs162/Chapter-9-File-Systems/"><meta property="article:section" content="cs162"><meta property="article:modified_time" content="2023-01-11T00:22:58+00:00"><meta property="og:site_name" content="🗒️ Ben's Notes"><title>Chapter 9: File Systems | 🗒️ Ben's Notes</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.a861a34b0976720d1504be0c2ee9870137640447a7fcac0c288dc885ce0f9bdb.css integrity="sha256-qGGjSwl2cg0VBL4MLumHATdkBEen/KwMKI3Ihc4Pm9s=" crossorigin=anonymous><meta charset=utf-8><meta name=description content="I/O #  Drivers #   A computer handles I/O on its end using several mechanisms:
 The bus, a common set of communication wires, carries data transfer transactions between devices.  A typical modern bus standard is PCI (Peripheral Component Interconnect), which is a parallel bus that can handle one transaction at a time. One major downside to this is that the bus speed must be set to the slowest connected device."><title>Chapter 9: File Systems</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://notes.bencuan.me//favicon.png><link href=https://notes.bencuan.me/styles.e08ceb33360cec132feb69cfb982e2a4.min.css rel=stylesheet><link href=https://notes.bencuan.me/quartz/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><link rel=preload href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css as=style onload='this.onload=null,this.rel="stylesheet"' integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://notes.bencuan.me/quartz/js/darkmode.9d3e1c1ebec61822893ee54cff5423d0.min.js></script>
<script src=https://notes.bencuan.me/quartz/js/util.c69e233dc1cc331a30b0f670e657b425.min.js></script>
<script async src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script async src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://notes.bencuan.me/quartz/js/popover.f03552ccb84d99ca615d1cfb9abde59e.min.js></script>
<script defer src=https://notes.bencuan.me/quartz/js/code-title.ce4a43f09239a9efb48fee342e8ef2df.min.js></script>
<script defer src=https://notes.bencuan.me/quartz/js/clipboard.2913da76d3cb21c5deaa4bae7da38c9f.min.js></script>
<script defer src=https://notes.bencuan.me/quartz/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const SEARCH_ENABLED=!1,LATEX_ENABLED=!0,PRODUCTION=!0,BASE_URL="https://notes.bencuan.me/",fetchData=Promise.all([fetch("https://notes.bencuan.me/indices/linkIndex.4cf79553ca8debc59a551ad2d349fa28.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://notes.bencuan.me/indices/contentIndex.4d234e6144b9797f4120c82bad94173d.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,i=t==n;addCopyButtons(),addCollapsibleCallouts(),initPopover("https://notes.bencuan.me",!0);const s=document.getElementById("footer");if(s){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=!0;drawGraph("https://notes.bencuan.me",t,[{"/cs61b":"#4388cc"},{"/data102":"#ba0af0"},{"/cs70":"#70fa70"},{"/cs61a":"#fbff22"},{"/cs186":"#ffaf1c"},{"/cs168":"#ff86a1"},{"/cs162":"#ffdfdd"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}var o=document.getElementsByClassName("mermaid");o.length>0&&import("https://unpkg.com/mermaid@9/dist/mermaid.esm.min.mjs").then(e=>{e.default.init()})},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'’':"'"},throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://notes.bencuan.me/quartz/js/full-text-search.e6e2e0c213187ca0c703d6e2c7a77fcd.min.js></script><header class=book-header><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h1 id=page-title><a href=https://notes.bencuan.me/>🗒️ Ben's Notes</a></h1><div class=spacer></div><div id=search-icon class=quartz-search><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control><main class=flex><aside class=book-menu><div class=book-menu-content><nav><div class=menu-search><div id=search-icon class=quartz-search><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div></div><ul><li><input type=checkbox id=section-da99de074169576d9f77860d41691a68 class=toggle>
<label for=section-da99de074169576d9f77860d41691a68 class="flex justify-between"><a href=/cs61b/ class=book-collapse-toggle>CS 61B: Data Structures</a></label><ul><li><span class=book-menu-title>Object Oriented Programming</span><ul><li><a href=/cs61b/oop/inheritance/>Inheritance</a></li><li><a href=/cs61b/oop/access-control/>Access Control</a></li><li><a href=/cs61b/oop/dynamic-method-selection/>Dynamic Method Selection</a></li><li><a href=/cs61b/oop/objects/>Java Objects</a></li><li><a href=/cs61b/oop/generics/>Generic Types</a></li></ul></li><li><span class=book-menu-title>Asymptotics</span><ul><li><a href=/cs61b/asymptotics/asymptotics/>Asymptotic Analysis Basics</a></li><li><a href=/cs61b/asymptotics/amortization/>Amortization</a></li><li><a href=/cs61b/asymptotics/asymptotics-practice/>Asymptotics Practice</a></li></ul></li><li><span class=book-menu-title>Abstract Data Types</span><ul><li><input type=checkbox id=section-70dba6a254ce0b2bcdb77dd58dbf6cdc class=toggle>
<label for=section-70dba6a254ce0b2bcdb77dd58dbf6cdc class="flex justify-between"><a href=/cs61b/abstract-data-types/collections/ class=book-collapse-toggle>Collections</a></label><ul><li><a href=/cs61b/abstract-data-types/collections/arrays/>Arrays</a></li><li><a href=/cs61b/abstract-data-types/collections/linked-lists/>Linked Lists</a></li><li><a href=/cs61b/abstract-data-types/collections/sets/>Sets</a></li><li><a href=/cs61b/abstract-data-types/collections/stacks-and-queues/>Stacks and Queues</a></li></ul></li><li><input type=checkbox id=section-5eb2d5b415a82a45c7861774887e844b class=toggle>
<label for=section-5eb2d5b415a82a45c7861774887e844b class="flex justify-between"><a href=/cs61b/abstract-data-types/binary-trees/ class=book-collapse-toggle>Binary Trees</a></label><ul><li><a href=/cs61b/abstract-data-types/binary-trees/balanced-search-structures/>Balanced Search Structures</a></li><li><a href=/cs61b/abstract-data-types/binary-trees/heaps/>Heaps</a></li><li><a href=/cs61b/abstract-data-types/binary-trees/tries/>Tries</a></li></ul></li><li><a href=/cs61b/abstract-data-types/graphs/>Graphs</a></li><li><a href=/cs61b/abstract-data-types/hashing/>Hashing and Hash Tables</a></li><li><a href=/cs61b/abstract-data-types/union-find-disjoint-sets/>Union Find (Disjoint Sets)</a></li><li><a href=/cs61b/abstract-data-types/comparables-and-comparators/>Comparables and Comparators</a></li></ul></li><li><span class=book-menu-title>Algorithms</span><ul><li><input type=checkbox id=section-26838f44377a3dfc0925929b8b82de69 class=toggle>
<label for=section-26838f44377a3dfc0925929b8b82de69 class="flex justify-between"><a href=/cs61b/algorithms/searching/ class=book-collapse-toggle>Searching</a></label><ul><li><a href=/cs61b/algorithms/searching/binary-search/>Binary Search</a></li><li><a href=/cs61b/algorithms/searching/breadth-first-search-bfs/>Breadth First Search (DFS)</a></li><li><a href=/cs61b/algorithms/searching/depth-first-search-dfs/>Depth First Search (DFS)</a></li></ul></li><li><input type=checkbox id=section-fd5238a874e42ff4e1ab0e65c20a9824 class=toggle>
<label for=section-fd5238a874e42ff4e1ab0e65c20a9824 class="flex justify-between"><a href=/cs61b/algorithms/shortest-paths/ class=book-collapse-toggle>Shortest Paths</a></label><ul><li><a href=/cs61b/algorithms/shortest-paths/dijkstras-algorithm/>Dijkstra's Algorithm</a></li><li><a href=/cs61b/algorithms/shortest-paths/a-search/>A* Search</a></li></ul></li><li><input type=checkbox id=section-434cf8cf80558e0886666bff24d740d1 class=toggle>
<label for=section-434cf8cf80558e0886666bff24d740d1 class="flex justify-between"><a href=/cs61b/algorithms/minimum-spanning-trees/ class=book-collapse-toggle>Minimum Spanning Trees</a></label><ul><li><a href=/cs61b/algorithms/minimum-spanning-trees/kruskals-algorithm/>Kruskal's Algorithm</a></li><li><a href=/cs61b/algorithms/minimum-spanning-trees/prims-algorithm/>Prim's Algorithm</a></li></ul></li><li><a href=/cs61b/algorithms/sorting/>Sorting</a></li><li><a href=/cs61b/algorithms/minimax/>Minimax Algorithm</a></li></ul></li><li><span class=book-menu-title>Misc. Topics</span><ul><li><a href=/cs61b/misc-topics/exceptions/>Exceptions</a></li><li><a href=/cs61b/misc-topics/modular-arithmetic/>Modular Arithmetic</a></li><li><a href=/cs61b/misc-topics/more-resources/>More Resources</a></li></ul></li></ul></li><li><input type=checkbox id=section-ee67b82ee54e976a9f81e3e41661ae13 class=toggle>
<label for=section-ee67b82ee54e976a9f81e3e41661ae13 class="flex justify-between"><a href=/cs70/ class=book-collapse-toggle>CS 70: Discrete Math</a></label><ul><li><a href=/cs70/latex-reference/>LaTeX Reference</a></li><li><span class=book-menu-title>Discrete Math</span><ul><li><a href=/cs70/discrete-math/overview/>Discrete Math Overview</a></li><li><a href=/cs70/discrete-math/propositional-logic/>Propositional Logic</a></li><li><a href=/cs70/discrete-math/proofs/>Proofs</a></li><li><a href=/cs70/discrete-math/stable-matching/>Stable Matching</a></li><li><a href=/cs70/discrete-math/graphs/>Graphs</a></li><li><a href=/cs70/discrete-math/modular-arithmetic/>Modular Arithmetic</a></li><li><a href=/cs70/discrete-math/rsa-cryptography/>RSA Cryptography</a></li><li><a href=/cs70/discrete-math/polynomials/>Polynomials</a></li><li><a href=/cs70/discrete-math/countability/>Countability</a></li><li><a href=/cs70/discrete-math/computability/>Computability</a></li></ul></li><li><span class=book-menu-title>Probability</span><ul><li><a href=/cs70/probability/probability-overview/>Probability Overview</a></li><li><a href=/cs70/probability/counting/>Counting</a></li><li><a href=/cs70/probability/discrete-probability/>Discrete Probability</a></li><li><a href=/cs70/probability/hashing-and-the-union-bound/>Hashing and the Union Bound</a></li><li><a href=/cs70/probability/expectation-and-variance/>Expectation and Variance</a></li><li><a href=/cs70/probability/concentration-inequalities/>Concentration Inequalities</a></li><li><a href=/cs70/probability/continuous-probability/>Continuous Probability</a></li><li><a href=/cs70/probability/markov-chains/>Markov Chains</a></li><li><a href=/cs70/probability/the-beta-family/>The Beta Family</a></li><li><a href=/cs70/probability/conditional-expectation-and-variance/>Conditional Expectation and Variance</a></li></ul></li></ul></li><li><input type=checkbox id=section-6d80b867b0e7b10bf4afdb6cb30147b7 class=toggle>
<label for=section-6d80b867b0e7b10bf4afdb6cb30147b7 class="flex justify-between"><a href=/cs186/ class=book-collapse-toggle>CS 186: Databases</a></label><ul><li><a href=/cs186/io/>What is an I/O and why should I care?</a></li><li><a href=/cs186/00-SQL-Basics/>SQL Basics</a></li><li><a href=/cs186/01-Disks-Buffers-Files/>Disks, Buffers, and Files</a></li><li><a href=/cs186/02-B+-Trees/>B+ Trees</a></li><li><a href=/cs186/03-Buffer-Management/>Buffer Management</a></li><li><a href=/cs186/04-Sorting-and-Hashing/>Sorting and Hashing</a></li><li><a href=/cs186/05-Iterators-and-Joins/>Iterators and Joins</a></li><li><a href=/cs186/06-Relational-Algebra/>Relational Algebra</a></li><li><a href=/cs186/07-Query-Optimization/>Query Optimization</a></li><li><a href=/cs186/08-Transactions/>Transactions and ACID</a></li><li><a href=/cs186/09-Parallel-Query-Processing/>Parallel Query Processing</a></li><li><a href=/cs186/10-Recovery/>Recovery</a></li><li><a href=/cs186/11-Distributed-Transactions/>Distributed Transactions</a></li><li><a href=/cs186/12-ER-Diagrams/>E-R Diagrams</a></li></ul></li><li><input type=checkbox id=section-a5f138e4453c6deda66a767c13d8a673 class=toggle checked>
<label for=section-a5f138e4453c6deda66a767c13d8a673 class="flex justify-between"><a href=/cs162/ class=book-collapse-toggle>CS 162: Operating Systems</a></label><ul><li><a href=/cs162/Chapter-1-OS-Basics/>Chapter 1: OS Basics</a></li><li><a href=/cs162/Chapter-2-Processes/>Chapter 2: Processes</a></li><li><a href=/cs162/Chapter-3-Threads/>Chapter 3: Threads</a></li><li><a href=/cs162/Chapter-4-I-O/>Chapter 4: I/O</a></li><li><a href=/cs162/Chapter-5-Synchronization/>Chapter 5: Synchronization</a></li><li><a href=/cs162/Chapter-6-Scheduling/>Chapter 6: S cheduling</a></li><li><a href=/cs162/Chapter-7-Address-Translation/>Chapter 7: Address Translation</a></li><li><a href=/cs162/Chapter-8-Caching/>Chapter 8: Caching</a></li><li><a href=/cs162/Chapter-9-File-Systems/ class=active>Chapter 9: File Systems</a></li><li><a href=/cs162/Appendix-A-GDB-foobars/>GDB Reference</a></li></ul></li><li><input type=checkbox id=section-d6662b440d117f766a2c3bdd162dce8f class=toggle>
<label for=section-d6662b440d117f766a2c3bdd162dce8f class="flex justify-between"><a href=/cs168/ class=book-collapse-toggle>CS 168: The Internet</a></label><ul><li><a href=/cs168/intro-to-the-internet/>Intro to the Internet</a></li><li><a href=/cs168/cli/>CLI Tools</a></li><li><a href=/cs168/intradomain-routing/>Introduction to Routing</a></li><li><a href=/cs168/measuring-link-performance/>Measuring Link Performance</a></li><li><a href=/cs168/resource-sharing-packet-and-circuit-switching/>Resource Sharing</a></li><li><a href=/cs168/internet-organization-and-layers/>Internet Organization</a></li><li><a href=/cs168/sockets-and-ports/>Sockets and Ports</a></li><li><a href=/cs168/addressing-ip/>Addressing</a></li><li><a href=/cs168/interdomain-routing-bgp/>Interdomain Routing (BGP)</a></li><li><a href=/cs168/TCP/>TCP</a></li><li><a href=/cs168/reliability/>Reliability</a></li><li><a href=/cs168/congestion-control/>Congestion Control</a></li><li><a href=/cs168/dns/>DNS</a></li><li><a href=/cs168/web/>Web</a></li><li><a href=/cs168/ethernet/>Ethernet</a></li><li><a href=/cs168/end-to-end-operation/>End to End Operation</a></li><li><a href=/cs168/final-review/>Final Review</a></li></ul></li><li><input type=checkbox id=section-0ab56f4e325729fc5ee23c1204712a3e class=toggle>
<label for=section-0ab56f4e325729fc5ee23c1204712a3e class="flex justify-between"><a href=/cs61a/ class=book-collapse-toggle>CS 61A: Computer Programs</a></label><ul><li><a href=/cs61a/resources/>Resources</a></li><li><a href=/cs61a/midterm-tips/>Midterm Tips</a></li></ul></li><li><input type=checkbox id=section-7a47eedeadc37bd22193fe5cd002031e class=toggle>
<label for=section-7a47eedeadc37bd22193fe5cd002031e class="flex justify-between"><a href=/data102/ class=book-collapse-toggle>Data 102: Inference</a></label><ul><li><a href=/data102/binary-decision-making/>Binary Decision Making</a></li><li><a href=/data102/hypothesis-testing/>Hypothesis Testing</a></li><li><a href=/data102/decision-theory/>Decision Theory</a></li><li><a href=/data102/parameter-estimation/>Parameter Estimation</a></li><li><a href=/data102/sampling/>Sampling</a></li><li><a href=/data102/regression-and-glms/>Regression and GLMs</a></li><li><a href=/data102/nonparametric-methods/>Nonparametric Methods</a></li><li><a href=/data102/interpretability/>Interpretability</a></li><li><a href=/data102/causality/>Causality</a></li><li><a href=/data102/concentration-inequalities/>Concentration Inequalities</a></li><li><a href=/data102/bandits/>Bandits</a></li><li><a href=/data102/Markov-Decision-Processes/>Markov Decision Processes</a></li><li><a href=/data102/Reinforcement-Learning/>Reinforcement Learning</a></li></ul></li></ul><ul><li><a href=/contributing target=_blank rel=noopener>Contribute</a></li><li><a href=https://github.com/64bitpandas/notes/issues target=_blank rel=noopener>Feedback</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class="book-page container"><article class=markdown><h1 class=title>Chapter 9: File Systems</h1><h1 id=io>I/O
<a class=anchor href=#io>#</a></h1><h2 id=drivers>Drivers
<a class=anchor href=#drivers>#</a></h2><p><img src=https://notes.bencuan.me/cs162/Chapter%209%20File%20Systems/Untitled.png width=auto alt=Untitled></p><p>A computer handles I/O on its end using several mechanisms:</p><ul><li>The <strong>bus,</strong> a common set of communication wires, carries data transfer transactions between devices.<ul><li>A typical modern bus standard is <strong>PCI</strong> (Peripheral Component Interconnect), which is a parallel bus that can handle one transaction at a time. One major downside to this is that the bus speed must be set to the slowest connected device.</li><li>PCI has evolved into PCI-Express, which is a collection of fast serial channels (lanes) in which devices can use as many as necessary to achieve a desired bandwidth. In this ways, devices can still use the old PCI standard, but don&rsquo;t have to share lanes with other devices.</li></ul></li><li><strong>Controllers,</strong> which sit between the CPU and I/O devices and contain a set of registers and memory that can be interfaced with.</li></ul><p>A processor can interact with device data in one of two ways:</p><ul><li><strong>Port-Mapped I/O:</strong> using assembly instructions to directly grab data.</li><li><strong>Memory-Mapped I/O:</strong> devices asynchronously read and write data from memory, and the CPU can use standard load and store operations to access this memory. Memory-mapped IO generally requires polling (see below for consequences of this fact).</li></ul><p>Transferring data to and from a device controller can be done in one of two ways:</p><ul><li><strong>Programmed I/O:</strong> every byte is simply transferred via port-mapped or memory-mapped I/O operations.<ul><li>This is good because it keeps the hardware and software simple, but the amount of processor cycles it requires grows proportionally to the amount of data. (i.e. bad for huge chunks of data)</li></ul></li><li><strong>Direct Memory Access (DMA):</strong> give the device controller direct access to a memory bus (acts on physical memory).<ul><li>The <strong>top half</strong> of a DMA scheme, the device driver interface, starts a request.</li><li>The <strong>bottom half</strong> consists of the code that executes on DMA completion (when the DMA controller interrupts the CPU).</li></ul></li></ul><p>There are two ways to notify the OS about I/O events:</p><ul><li><p><strong>Polling</strong> is when the OS periodically checks device status registers for operations that need to be completed.</p><ul><li>This is best for frequent, predictable I/O events, since there is low overhead; however, polling can waste CPU cycles if no I/O events are occurring.</li></ul></li><li><p><strong>Interrupts</strong> are generated by the device whenever it needs service.</p><p>This is best for handling infrequent or unpredictable events, since there is high overhead on interrupt.</p></li></ul><p>Modern devices usually combine polling and interrupts: for example, network adapters could use interrupts to wait for the first packet, then poll for subsequent packets.</p><p>Several types of standard interfaces can be implemented to make accessing devices more consistent:</p><ul><li><strong>Block devices</strong> access blocks of data at one time using <code>open()</code>, <code>read()</code>, <code>write()</code>, and <code>seek()</code>.<ul><li>This type of interface is best used for storage devices such as hard drives or CD readers.</li></ul></li><li><strong>Character devices</strong> access individual bytes at a time using <code>get()</code> and <code>put()</code>.<ul><li>This type of interface is most appropriate for devices that use small amounts of data, such as keyboards or printers.</li></ul></li><li><strong>Blocking interfaces</strong> put the process to sleep until the device or data is ready for I/O.</li><li><strong>Non-blocking interfaces</strong> return quickly from read or write requests with the number of bytes successfully transferred. These interfaces are not guaranteed to return anything at all.</li><li><strong>Asynchronous interfaces</strong> return pointers to buffers that will eventually be filled with data, then notifies the user when the pointer has been obtained.</li></ul><h2 id=storage-devices>Storage Devices
<a class=anchor href=#storage-devices>#</a></h2><h3 id=hdd>HDD
<a class=anchor href=#hdd>#</a></h3><p>Hard drives are magnetic disks that contain tracks of data around a cylinder.</p><p>HDD&rsquo;s are generally good for sequential reading, but bad for random reads.</p><p><img src=https://notes.bencuan.me/cs162/../../../CS186%20Notes%204a084a8a0e22428d9443c551eda9dfe0/Untitled%20Database%208925b4d3c6734c3fa260dd5d5e752782/Disks,%20Buffers,%20Files/Untitled%201.png width=auto alt=Untitled></p><p><strong>Disk Latency = Queueing Time + Controller Time + Seek Time + Rotation Time + Transfer Time</strong></p><ul><li>Queuing Time: amount of time it takes for the job to be taken off the OS queue</li><li>Controller Time: amount of time it takes for information to be sent to disk controller</li><li>Seek Time: amount of time it takes for the arm to position itself over the correct track</li><li>Rotation Time (rotational latency): amount of time it takes for the arm to rotate under the head (average is 1/2 a rotation)</li><li>Transfer Time: time it takes to transfer the required sectors from disk to memory</li></ul><p>HDD Question: Calculating size and throughput</p><p>Suppose a hard drive has the following spects:</p><ul><li>4kb sectors</li><li>3 million sectors per track</li><li>100 tracks per platter</li><li>2 platters (1 sided)</li><li>5400 rpm</li><li>5.6ms average seek time</li><li>1ms controller+queue time</li><li>140 MB/s transfer rate</li></ul><p>The size of the hard drive is equal to (size of sector) x (num sectors per track) x (num tracks per plattter) * (num platters) = 4096B * 3000000 * 100 * 2, or about 2.46TB.</p><p>For a 64KB read, the throughput can be calculated as bytes/latency, or</p><p>64KB/((queue + controller time) + seek time + rotation time + transfer time).</p><ul><li>The queue, controller, and seek times are all given in the problem.</li><li>Average rotation time is (1/2) * (time for one rotation) = 0.5/5400 = 5.55ms.</li><li>The transfer time is (bytes)/(transfer rate) = 64/140 = 0.457ms.</li><li>All together, the throughput is 64KB/(1+ 5.6 + 5.55 + 0.457)ms = 5079KB/s.</li></ul><h3 id=ssd>SSD
<a class=anchor href=#ssd>#</a></h3><p>Solid state drives store data in non-volatile, NAND flash memory cells that don&rsquo;t have any moving parts.</p><ul><li>This means that seek time and rotation time are essentially reduced to a single short access time.</li><li>Writing data to an SSD can get complex and time-consuming, because writing can only be done to an empty page. Generally, writing takes 10x as long as reading, and erasing blocks takes 10x as long as writing.</li><li>To mitigate long erasure times and lower NAND durability:<ul><li>Maintain a <strong>flash translation layer (FTL)</strong> which maps virtual block numbers to physical page numbers in RAM. This way, the SSD can relocate data at will without the OS caring.</li><li><strong>Copy on write:</strong> instead of overwriting the entire page when the OS updates its data, we can write a new version in a free page and update the FTL mapping to point to the new location. This allows writing without the costly erasure step.</li></ul></li></ul><p><strong>SSD Latency = Queueing Time + Controller Time + Transfer Time</strong></p><h2 id=queuing-theory>Queuing Theory
<a class=anchor href=#queuing-theory>#</a></h2><p><strong>Latency</strong> (response time) is the amount of time needed to perform an operation.</p><p><strong>Bandwidth</strong> (throughput) is the rate at which operations are performed.</p><p><strong>Overhead</strong> (startup) is the time taken to initiate an operation.</p><p>Latency for an n-byte operation = Overhead + n/Bandwidth (linear with respect to the number of bytes)</p><p>A server that processes $N$ jobs per second is better than $N$ servers that process 1 job per second due to load balancing decreasing utilization.</p><p>$\mu$ = average service rate (in jobs per second)</p><p>$S$ = $T_s$ = $m$ = average service time = $\frac{1}{\mu}$</p><p>$C$ = squared coefficient of variance = $\frac{\sigma^2}{S^2}$</p><p>$\lambda$ = average arrival rate (in jobs per second)</p><p>$U$ = utilization (fraction from 0 to 1) = $\frac{\lambda}{\mu} = \lambda S$</p><p>$T_q$ = average queueing time (waiting time)</p><p>$Q$ = $L_q$ average length of queue = $\lambda T_q$ (Little&rsquo;s Law)</p><p>Memoryless service time distribution with $C = 1$ (M/M/1 Queue): $T_q = S \times \frac{u}{1-u}$</p><p>General service time distribution (M/G/1 Queue): $T_q = S \times \frac{1+C}{2} \times \frac{u}{1-u}$</p><h3 id=queuing-theory-questions>Queuing Theory Questions
<a class=anchor href=#queuing-theory-questions>#</a></h3><p>A job enters every 5 seconds, and completes in 60 seconds. What is the average queue length?</p><ul><li>$L_q = \lambda T_q$ (Little&rsquo;s Law).</li><li>The average arrival rate, $\lambda$, is 1 job per 5 seconds, or 0.2.</li><li>$T_q$ is 60 seconds.</li><li>So $L_q = 0.2 \times 60 = 12$.</li></ul><p>To solve for $\lambda$:</p><h1 id=file-systems>File Systems
<a class=anchor href=#file-systems>#</a></h1><p>Best to worst ranked</p><p><strong>Sequential Access:</strong></p><ol><li>Extent-based (NTFS) - files are contiguously allocated</li><li>Linked (FAT) - traversing linked list</li><li>Indexed (FFS) - nested inodes</li></ol><p><strong>Random Access:</strong></p><ol><li>Extent-based</li><li>Indexed</li><li>Linked</li></ol><p><strong>Disk Capacity:</strong></p><ol><li>Linked</li><li>Indexed</li><li>Extent-based (prone to external fragmentation)</li></ol><h2 id=fat>FAT
<a class=anchor href=#fat>#</a></h2><p>FAT stands for File Allocation Table. This file system consists of a table with entries that correspond one-to-one with blocks and stores information in a linked list format. (For example, file number 31 could point to 62, which could point to 53&mldr; all of these blocks in the table when read in order create a file.)</p><ul><li>FAT is good for sequential access (due to linked list structure), but terrible for random access (since you have to traverse the list to get to where you want).</li><li>FAT is not prone to external fragmentation since subsequent blocks can go wherever there is free space, but internal fragmentation is severe in small files since blocks are a fixed size and you need at least one for each file regardless of the size.</li><li>FAT has poor locality for files and metadata since file information is not stored sequentially.</li></ul><h2 id=linux-ffs>Linux FFS
<a class=anchor href=#linux-ffs>#</a></h2><p><img src=https://notes.bencuan.me/cs162/Chapter%209%20File%20Systems/Untitled%201.png width=auto alt=Untitled></p><p>FFS (Fast File System) was used in early Linux systems and stores file information in <strong>inodes.</strong></p><p>Each inode has file metadata and a list of pointers (direct, indirect, doubly indirect&mldr;) to blocks.</p><ul><li><p>FFS can be optimized for HDDs by splitting up the disk into block groups. All files in the same directory should be placed in the same block group.</p></li><li><p>FFS is pretty good for sequential access if optimized, since inode information is all stored together, and blocks should have some amount of locality if they are in the same block group.</p></li><li><p>Random access is also pretty good because you can just pick the pointer that you want from the inode.</p></li><li><p>There is no external fragmentation due tot the inode structure, but internal fragmentation can be pretty severe due to the overhead and fixed size of inodes.</p></li><li><p>Hard link vs soft link</p></li><li></li><li><p>Direct pointer, indirect pointer, doubly indirect pointer</p></li><li><p>Inode</p></li><li><p>Calculate maximum filesize</p></li></ul><h2 id=ntfs>NTFS
<a class=anchor href=#ntfs>#</a></h2><p>NTFS (New Technology File System) is currently used by Windows. Rather than an inode array like FFS, it uses a Master File Table. Each entry in the MFT contains file metadata and data; the main difference is that MFT entries can have variable size.</p><ul><li>If a file grows too large, then <strong>extents</strong> add extra pointers into a MFT entry.</li></ul><h2 id=directories>Directories
<a class=anchor href=#directories>#</a></h2><p>In the three file system designs above, directories are represented as a file containing name-to-filenumber mappings where one entry in the directory corresponds to a file or subdirectory. (In FAT, file metadata is also stored in the directory.)</p><p>Name-to-filenumber pairs stored in directories are called <strong>hard links,</strong> which can be created using the <code>link()</code> syscall.</p><ul><li>In non-FAT filesystems, a file can have more than one hard link (i.e. be part of two different directories).</li><li>A file will not be removed unless all hard links to that file are removed (so a reference count is needed to track them).</li></ul><p><strong>Soft links</strong> are a special entry in directory files with name-to-path mappings. Whenever the original name is accessed, the OS will look up the file corresponding to the stored path.</p><ul><li>Soft links can be created using the <code>symlink()</code> syscall.</li><li>There is no reference count needed for soft links: if the path doesn&rsquo;t exist or the file is deleted, then lookup will simply fail.</li></ul><h1 id=distributed-systems>Distributed Systems
<a class=anchor href=#distributed-systems>#</a></h1><h2 id=durability>Durability
<a class=anchor href=#durability>#</a></h2><p><strong>How do we prevent loss of data due to disk failure?</strong></p><h3 id=raid>RAID
<a class=anchor href=#raid>#</a></h3><p>Redundant Array of Inexpensive Disks. Rather than using one large, expensive, reliable disk, we use a large amount of small, expensive, unreliable disks and duplicate the data across the disks.</p><ul><li><strong>RAID 0:</strong> No redundancy, striped volumes only. Very unreliable (any one disk failure means data loss).</li><li><strong>RAID 1:</strong> Disk mirroring. Every disk is fully duplicated onto its mirror. This produces a very large data availability and optimized read rates, but at the cost of needing 100% overhead.</li><li><strong>RAID 3:</strong> Parity disk. For every 3 disks, 1 additional disk is used to store parity information (so 1/4 of the data cost as RAID 1). If any one of the four disks fails, the data will still be intact.</li><li><strong>RAID 4:</strong> Disk sectors. Rather than operating at the bit level (like RAID 3), RAID 4 operates on a stripe level. Reads and writes must be done both to the original disk and the parity disk. This works well for small reads, but small writes can be problematic because every modified stripe needs to be parity checked. So the bottleneck becomes the parity disk.</li><li><strong>RAID 5:</strong> Interleaved parity. In a larger array, an independent set of parity disks each contain a few stripes for each drive. This cuts down on write bottlenecks since the chance of multiple drives writing to the same parity drive is reduced.</li><li><strong>RAID 6:</strong> RAID 5 with two parity blocks per stripe. So the drive array can tolerate 2 disk failures rather than just 1, at the cost of needing additional capacity.</li></ul><h2 id=reliability>Reliability
<a class=anchor href=#reliability>#</a></h2><p>Reliability is the guarantee that data remains in a consistent state after recovering from disk failure. This differs from durability since the former deals with the recovery step itself.</p><h3 id=transactions>Transactions
<a class=anchor href=#transactions>#</a></h3><p>A <strong>Transaction</strong> is an atomic sequence that takes a system from one consistent state to another. Transactions follow four properties (ACID):</p><ul><li>Atomicity: transaction must complete in its entirety, or not at all</li><li>Consistency: transactions go from one consistent state to another, and cannot compromise integrity</li><li>Isolation: transactions should not interfere with each other if executed concurrently</li><li>Durability: once a transaction is made, it will not be erased on disk failure.</li></ul><h3 id=journaling-filesystem>Journaling Filesystem
<a class=anchor href=#journaling-filesystem>#</a></h3><p>One way to guarantee reliability in a filesystem is to write operations to a log first. Once the whole transaction is written to the log, the disk will then apply the necessary changes.</p><ul><li>If the system crashes when writing to the log, then the transaction will not be applied.</li><li>If the system crashes when applying disk changes, then we can simply observe that the log was not completed and re-apply the transaction. This is guaranteed to work for <strong>idempotent</strong> transactions (applying multiple times will have same effect as applying once).</li></ul><p>EXT3 is basically FFS but with logging.</p><p>A <strong>log structured file system</strong> takes logging to another level by making the entire filesystem one log.</p><h2 id=consensus-making>Consensus Making
<a class=anchor href=#consensus-making>#</a></h2><p>Previously, we talked about transactions on a single machine. But what if we have lots of computers, and need to coordinate transactions between them? It&rsquo;s possible for one machine to be in an inconsistent state while the others are operating normally.</p><h3 id=two-phase-commit>Two-Phase Commit
<a class=anchor href=#two-phase-commit>#</a></h3><p>2PC is a scheme for distributed consensus making. It proceeds as follows:</p><ul><li>One machine is the coordinator; all others are participants (workers).</li><li>When the coordinator receives a request, it logs it then sends a <code>VOTE-REQUEST</code> to workers.</li><li>Each worker records their own vote in their log.</li><li>Each worker then sends a <code>VOTE-ABORT</code> or <code>VOTE-COMMIT</code>.</li><li>If all workers send <code>VOTE-COMMIT</code>, then the coordinator writes a commit in their log and sends <code>GLOBAL-COMMIT</code> to all workers.</li><li>Workers then perform the commit and send an <code>ACK</code> on completion.</li></ul><p>If one or more workers send <code>VOTE-ABORT</code> or times out, then the coordinator sends a <code>GLOBAL-ABORT</code> and no operation should be completed.</p><p><img src=https://notes.bencuan.me/cs162/Chapter%209%20File%20Systems/Untitled%202.png width=auto alt=Untitled></p><p><strong>General&rsquo;s Paradox:</strong></p><p>Messages over an unreliable network cannot guarantee entities to do something simultaneously. However, this doesn&rsquo;t apply to 2PC because there is no simultaneous operation.</p><h1 id=network-systems>Network Systems
<a class=anchor href=#network-systems>#</a></h1><h2 id=layers>Layers
<a class=anchor href=#layers>#</a></h2><p><img src=https://notes.bencuan.me/cs162/Chapter%209%20File%20Systems/Untitled%203.png width=auto alt=Untitled></p><h2 id=tcp-vs-udp>TCP vs UDP
<a class=anchor href=#tcp-vs-udp>#</a></h2><p><img src=https://notes.bencuan.me/cs162/Chapter%209%20File%20Systems/Untitled%204.png width=auto alt=Untitled></p><p><img src=https://notes.bencuan.me/cs162/Chapter%209%20File%20Systems/Untitled%205.png width=auto alt=Untitled></p><p><img src=https://notes.bencuan.me/cs162/../../CS161%20Notes%2058b7c6378df74bef8c48f2d39dbe9a72/Notes%208cc979bb2e384250a5fa4b59ec87672e/Networking/Untitled%207.png width=auto alt=Untitled></p><h2 id=remote-procedure-calls>Remote Procedure Calls
<a class=anchor href=#remote-procedure-calls>#</a></h2><p><img src=https://notes.bencuan.me/cs162/Chapter%209%20File%20Systems/Untitled%206.png width=auto alt=Untitled></p><p>RPC&rsquo;s (remote procedure calls) are an interface to call functions on another machine.</p><h2 id=distributed-filesystems>Distributed Filesystems
<a class=anchor href=#distributed-filesystems>#</a></h2><p><img src=https://notes.bencuan.me/cs162/Chapter%209%20File%20Systems/Untitled%207.png width=auto alt=Untitled></p><p>Create an abstraction (virtual file system, VFS) that allows the system to interact with remote files as if they were local.</p><ul><li>NFS (network file system) translates read and write calls into RPC&rsquo;s.<ul><li>These RPC&rsquo;s are stateless and idempotent: they contain information for the entire operation.</li><li>Results are cached on the local system. The server is polled periodically to check for changes.</li><li>Write-through caching (writing all changes on server before returning to client) is used.</li><li>Multiple writes from different clients simultaneously create undefined results.</li></ul></li></ul><h2 id=end-to-end-argument>End-To-End Argument
<a class=anchor href=#end-to-end-argument>#</a></h2><p>The primary argument is that we can&rsquo;t trust the network, so we need to guarantee services on both ends.</p><div class=like-button><link rel=stylesheet href=https://api.bencuan.me/public/applause-button.css><script src=https://api.bencuan.me/public/applause-button.js></script>
<applause-button style="width: 48px; height: 48px" multiclap=true color=#ff4faa api=https://api.bencuan.me></div><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://notes.bencuan.me/quartz/js/graph.cbd78cfa87df7d3e230d16fc24f06548.js></script></div></div><div id=contact_buttons><footer><p>Made with <a href=https://github.com/64bitpandas/amethyst>Amethyst</a>, © 2023 Ben Cuan</p><ul><li><a href=https://notes.bencuan.me/>Home</a></li><li><a href=https://github.com/64bitpandas/notes/issues>Feedback</a></li><li><a href=https://bencuan.me>Website</a></li></ul></footer></div></article><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#io>I/O</a><ul><li><a href=#drivers>Drivers</a></li><li><a href=#storage-devices>Storage Devices</a><ul><li><a href=#hdd>HDD</a></li><li><a href=#ssd>SSD</a></li></ul></li><li><a href=#queuing-theory>Queuing Theory</a><ul><li><a href=#queuing-theory-questions>Queuing Theory Questions</a></li></ul></li></ul></li><li><a href=#file-systems>File Systems</a><ul><li><a href=#fat>FAT</a></li><li><a href=#linux-ffs>Linux FFS</a></li><li><a href=#ntfs>NTFS</a></li><li><a href=#directories>Directories</a></li></ul></li><li><a href=#distributed-systems>Distributed Systems</a><ul><li><a href=#durability>Durability</a><ul><li><a href=#raid>RAID</a></li></ul></li><li><a href=#reliability>Reliability</a><ul><li><a href=#transactions>Transactions</a></li><li><a href=#journaling-filesystem>Journaling Filesystem</a></li></ul></li><li><a href=#consensus-making>Consensus Making</a><ul><li><a href=#two-phase-commit>Two-Phase Commit</a></li></ul></li></ul></li><li><a href=#network-systems>Network Systems</a><ul><li><a href=#layers>Layers</a></li><li><a href=#tcp-vs-udp>TCP vs UDP</a></li><li><a href=#remote-procedure-calls>Remote Procedure Calls</a></li><li><a href=#distributed-filesystems>Distributed Filesystems</a></li><li><a href=#end-to-end-argument>End-To-End Argument</a></li></ul></li></ul></nav></div></aside></main></body></html>