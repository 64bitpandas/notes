<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Discrete Math on</title><link>https://notes.bencuan.me/cs70/discrete-math/</link><description>Recent content in Discrete Math on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/cs70/discrete-math/index.xml" rel="self" type="application/rss+xml"/><item><title>Discrete Math Overview</title><link>https://notes.bencuan.me/cs70/discrete-math/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/overview/</guid><description>What even is discrete math? # According to Wikipedia, &amp;ldquo;Discrete mathematics is the study of mathematical structures that are fundamentally discrete rather than continuous.&amp;rdquo; Very helpful, thank you Wikipedia. The floor is indeed made of floor rather than sky.
The word discrete means &amp;ldquo;distinct&amp;rdquo; or &amp;ldquo;countable&amp;rdquo;. This suggests that discrete math has to do with countable numbers like integers, rather than the continuous $f(x)$functions we&amp;rsquo;re used to seeing that are defined for any real$x$, even ones we don&amp;rsquo;t know the exact value of like $\pi$.</description></item><item><title/><link>https://notes.bencuan.me/cs70/discrete-math/propositional-logic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/propositional-logic/</guid><description>What are Propositions? # Propositions are anything that can be true or false. This could include:
Statements like &amp;ldquo;Birds can fly&amp;rdquo;. Well defined equations with no free variables like $1 + 1 = 3$. Propositions are not:
Variables like $x$ or $5$. Equations with free variables like $P(x) = y$. Statements that aren&amp;rsquo;t clearly true or false, like &amp;ldquo;I like trains.&amp;rdquo; Connectives # Simple propositions can be joined together to make complex statements.</description></item><item><title/><link>https://notes.bencuan.me/cs70/discrete-math/proofs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/proofs/</guid><description>Introduction # A proof is a set of logical deductions that can be used to show how something is true. This is powerful because proofs can often be very general, allowing a truth to be used in a whole bunch of cases that don&amp;rsquo;t individually need to be re-proven.
There are a number of common proof techniques (although these certainly aren&amp;rsquo;t exhaustive!) outlined below.
Direct Proofs # In direct proofs, we can use the definitions directly to show that something is true.</description></item><item><title/><link>https://notes.bencuan.me/cs70/discrete-math/stable-matching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/stable-matching/</guid><description>Introduction # The stable matching problem deals with how to match one group to another group while trying to maximize everyone&amp;rsquo;s &amp;lsquo;happiness&amp;rsquo;.
It works best when the two groups are distinct (nobody can be in both groups at once) and the orderings are complete (everyone in the other group has to show up in all orderings). Before we get to examples of when this might apply, I&amp;rsquo;ll throw out a few examples where we can&amp;rsquo;t use this algorithm so you don&amp;rsquo;t get any wrong ideas:</description></item><item><title/><link>https://notes.bencuan.me/cs70/discrete-math/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/graphs/</guid><description>[!info] Content Note
This is a second introduction to graphs that assumes you&amp;rsquo;ve at least seen them before. Take a look at the 61B version if you feel lost!
What&amp;rsquo;s a graph? # Formally, a graph is a set of vertices with a set of edges connecting them. A graph can be defined as $G = (V, E)$ where $V = {A, B, \cdots V_n}$ and $E = {{A, B}, {B, C} \cdots }$</description></item><item><title>Modular Arithmetic</title><link>https://notes.bencuan.me/cs70/discrete-math/modular-arithmetic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/modular-arithmetic/</guid><description>What is Modular Arithmetic? # Modular arithmetic is &amp;ldquo;clock math&amp;rdquo; - that is, when numbers wrap around back to 0 if they get too big. You could think about it like a remainder: $21 \pmod{10}$ for example can be read as &amp;ldquo;what is the remainder of 21 when it is divided by 10?&amp;rdquo; (it&amp;rsquo;s 1, by the way.)
This is an important concept in many aspects of computer science, namely cryptography and error correction among many others.</description></item><item><title>RSA Cryptography</title><link>https://notes.bencuan.me/cs70/discrete-math/rsa-cryptography/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/rsa-cryptography/</guid><description>Introduction # The internet is built upon the fact that stuff needs to go from point A to point B quickly, accurately, and securely. We&amp;rsquo;ll talk about the secure part of that now (the accurate part will be addressed soon!).
One of the ways we can make sure our top-secret messages can&amp;rsquo;t get intercepted is to encrypt them- mix them up to become incomprehensible using some secret code, then decrypt it at the other end.</description></item><item><title>Polynomials</title><link>https://notes.bencuan.me/cs70/discrete-math/polynomials/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/polynomials/</guid><description>Introduction # &amp;ldquo;I learned this in 4th grade&amp;rdquo;, you say, &amp;ldquo;and I already know how to do Taylor approximations and binomial expansions and get local minima&amp;hellip; what else is there to do?&amp;rdquo; (At least that was my first thought :stuck_out_tongue:)
Turns out, polynomials are super useful in the world of discrete math. Here, we&amp;rsquo;ll cover two applications in discrete space, which are secret sharing and error correction.
Important Properties # Gotta do some quick review first!</description></item><item><title>Countability</title><link>https://notes.bencuan.me/cs70/discrete-math/countability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/countability/</guid><description>How big is infinity? Are some infinities bigger than others? The $\infty$is a rather mind-boggling concept; the principles of countability will hopefully make some sense out of it.
Bijections # A bijection is a mapping between two sets such that there exists a unique pairing from a particular element of one set to another.
These ideas of existence and uniqueness can be formalized by considering some different types of maps:</description></item><item><title>Computability</title><link>https://notes.bencuan.me/cs70/discrete-math/computability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/computability/</guid><description>Computability is the study of a massively important question: do there exist any problems that are impossible for a computer to solve?
The Halting Problem # It turns out that the above question itself is impossible to solve: in other words, there cannot exist a program HALT which determines if a program can halt in finite time given a particular input.
This was originally proposed by Alan Turing- he proved the nonexistence by attempting to feed the Halting Problem into itself: if the Halting Problem doesn&amp;rsquo;t halt, then it is supposed to output an answer.</description></item></channel></rss>