<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ðŸ’œ Welcome to Amethyst! on</title><link>https://notes.bencuan.me/</link><description>Recent content in ðŸ’œ Welcome to Amethyst! on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/balanced-search-structures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/balanced-search-structures/</guid><description>Balanced BSTs # {% hint style=&amp;ldquo;warning&amp;rdquo; %} Please read Binary Trees before continuing! {% endhint %}
Balanced Binary Search Trees are an even more specific subcategory of binary trees that have an important property: they are always bushy.
B Trees (2-4 Trees) # The basic idea: Nodes can hold multiple values now! When nodes have too many values, we will split it.
A 2-4 tree is named such because each parent can have 2 to 4 children.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/heaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/heaps/</guid><description>Heaps # What are Heaps? # A heap is a specific order of storing data, often in a list. Heaps are very similar to binary trees, but have some differences:
Unlike trees, heaps only care about the root node. Usually, the root node is either the largest or smallest value in the heap (corresponding with max-heaps and min-heaps), and we don&amp;rsquo;t care too much about the rest. Every element in the heap must be larger than all its children (in a max-heap) or smaller than all its children (in a min-heap).</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/README/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/README/</guid><description>Binary Trees # {% hint style=&amp;ldquo;success&amp;rdquo; %} &amp;ldquo;The most important concept in computer science&amp;rdquo; - Josh Hug {% endhint %}
Humble Origins # Linked lists are great, but we can do better! Let&amp;rsquo;s try rearranging the pointers in an interesting way.
Instead of starting at one end of the list, let&amp;rsquo;s set our first pointer at the middle of the list!
Now, let&amp;rsquo;s make new pointers going to the center of each sublist on the left and right of the center.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/tries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/tries/</guid><description>Tries # Main Ideas # A trie is a specific implementation of a set and is short for retrieval tree.
It only works on sets with a finite alphabet, like digits or ASCII characters, for example. The idea is that each node can act like an array containing all characters in the alphabet and we can just access the branches super fast by indexing into them!
Tries are fantastic for searching to see if a word is contained in a set.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/arrays/</guid><description>Arrays # {% hint style=&amp;ldquo;info&amp;rdquo; %} This page assumes prior knowledge of Python lists from CS61A or equivalent. {% endhint %}
Arrays are a very popular data structure that stores an indexed list of data. \
Properties # Fixed length: after instantiation, the length of an array cannot be changed. Every value in array is the same type and holds the same amount of bits in memory.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/linked-lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/linked-lists/</guid><description>Linked Lists # {% hint style=&amp;ldquo;info&amp;rdquo; %} This page assumes prior knowledge of linked lists from CS61A or equivalent. I&amp;rsquo;ll assume you have already worked with basic singly linked lists before. {% endhint %}
The linked list is an extremely common recursive data structure that allows storage and access of an arbitrary amount of data.
Feature List of an Effective Linked List # Rebranding- represents Node as an individual object rather than having one monolithic List type.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/README/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/README/</guid><description>Collections # Collection is a Java interface for common abstract data types that store multiple items in them.
Sub-Interfaces # Lists are indexed sequences with duplication. The two most common types are ArrayLists **** and Linked Lists. **** Sets **** are non-indexed sequences with no duplication. (That is, every value in a set is unique.) Maps are key-value pairs. See Hashing and Hash Tables for a description on one common map implementation, the HashMap.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/sets/</guid><description>Sets # {% hint style=&amp;ldquo;warning&amp;rdquo; %} This page is from my original notes and is not up to the latest quality standards. Read with care or help make it better! {% endhint %}
Basics # A Set stores a collection of values with no duplicates. Sets have no inherent order, so you can&amp;rsquo;t rely on expecting any value to come before any other value when iterating through them.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/stacks-and-queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/stacks-and-queues/</guid><description>Stacks and Queues # Stacks and queues are two very common data structures used for a variety of applications from CPU processes to finding shortest paths using Dijkstra&amp;rsquo;s Algorithm. Fundamentally, they are very similar in structure and only differ by the order in which items are popped from them.
Pushing and Popping # Pushing # Adding an item to a stack or queue is called pushing. This will either put the item on the top of a stack or in the back of a queue.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/comparables-and-comparators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/comparables-and-comparators/</guid><description>Comparables and Comparators # What is it? # A Comparable is a generic type that allows standardized comparisons between objects.
In other words, anything that has a compareTo() method can be a Comparable!
Many Java libraries already use Comparable without you knowing! Some of the more well-known ones are Collection and String.
CompareTo can&amp;rsquo;t return anything you want! # There are some very specific properties CompareTo needs to have!</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/graphs/</guid><description>Graphs # Introduction # Graphs are simply a collection of vertices connected by edges. They&amp;rsquo;re very similar to trees, but are much more versatile and don&amp;rsquo;t require hierarchical relationships like trees do.
For most purposes, we will be working with simple graphs that follow two rules:
There are no loops (a connection of a node to itself). There are no parallel edges (two edges that connect the same two vertices).</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/hashing/</guid><description>Hashing and Hash Tables # Data Indexed Sets: Introduction # So far, we&amp;rsquo;ve explored a whole bunch of ways we can store items, but they aren&amp;rsquo;t really optimized for general searching. What if we could get searching in $\Theta(1)$ time??? Wouldn&amp;rsquo;t that be nice!
Let&amp;rsquo;s try something: putting all of our data in a massive array. Let&amp;rsquo;s say that we know all our data falls into the range from 0 to 10,000 and make an array of 10,000 length to hold stuff.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/union-find-disjoint-sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/union-find-disjoint-sets/</guid><description>Union Find (Disjoint Sets) # {% hint style=&amp;ldquo;info&amp;rdquo; %} This is not a complete entry, because I feel like existing course materials already cover this in an extremely intuitive manner.
See lab 14 for an guide on how to implement your own Union Find structure! {% endhint %}
The Union Find data structure is a way of representing a bunch of nodes that are connected to each other in subsets.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/minimax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimax/</guid><description>Minimax Algorithm # Game Trees # The Minimax algorithm is often used for making AI&amp;rsquo;s for turn-based games. It relies on the use of a type of game tree, which maps out all of the possible moves that players can make.
In the tree, there are two types of nodes: maximizing nodes and minimizing nodes. The max-nodes represent you- you want to make your position as advantageous as possible (maximizing your score).</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/kruskals-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/kruskals-algorithm/</guid><description>Kruskal&amp;rsquo;s Algorithm # {% hint style=&amp;ldquo;warning&amp;rdquo; %} Before reading, review Minimum Spanning Trees and Union Find (Disjoint Sets) as they both make Kruskal&amp;rsquo;s algorithm possible! {% endhint %}
Conceptual Overview # Kruskal&amp;rsquo;s algorithm is another optimal way to construct a minimum spanning tree. It&amp;rsquo;s benefits are that it is conceptually very simple, and easy to implement. The idea is that first we sort all the edges of the graph in order of increasing weight.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/prims-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/prims-algorithm/</guid><description>Prim&amp;rsquo;s Algorithm # {% hint style=&amp;ldquo;warning&amp;rdquo; %} Before reading, review Minimum Spanning Trees, as that is the foundation of Prim&amp;rsquo;s algorithm! {% endhint %}
Conceptual Overview # Prim&amp;rsquo;s algorithm is an optimal way to construct a minimum spanning tree. It basically starts from an arbitrary vertex, then considers all its immediate neighbors and picks the edge with smallest weight to be part of the MST. Note: this creates a cut in the graph, where the two nodes in the MST being constructed are in one set, and every other vertex of the graph is in another set.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/README/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/README/</guid><description>Minimum Spanning Trees # Spanning Tree Definition # A spanning tree T is a subgraph of a graph G where T:
Is connected (there&amp;rsquo;s a path to every vertex) Is acyclic (no cycles) Includes every vertex (spanning property) Notice: the first two properties defines a tree structure, and the last property makes the tree spanning.
A minimum spanning tree is a spanning tree with minimum total edge weight.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/searching/binary-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/binary-search/</guid><description>Binary Search # Binary search is a way of finding a specific node in a tree. It only works on binary trees due to its helpful sorted property. It simply traverses the tree, moving left if the current node is too large or right if it is too small.
Binary search runs in $\Theta(\log(n))$ time for bushy trees, which is also the number of layers in a tree.
The Algorithm # public BST find(BST T, Key sk) { if (T == null) { return null; } if (sk.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/searching/breadth-first-search-bfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/breadth-first-search-bfs/</guid><description>Breadth First Search (BFS) # Breadth First Search (BFS), like Depth First Search (DFS), is a method of traversing a graph. BFS simply traverses in a different order, but otherwise is very similar to DFS.
The main difference is that BFS visits all children before any subgraphs. In a tree, we call this level order.
For the example tree above, a level order traversal would go in this order: D B F A C E G.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/searching/depth-first-search-dfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/depth-first-search-dfs/</guid><description>Depth First Search (DFS) # Depth First Traversal # Before we move on to searching, let&amp;rsquo;s talk about traversing. Traversal is the act of visiting nodes in a specific order. This can be done either in trees or in graphs.
For trees in particular, there are three main ways to traverse.
The first way is inorder traversal, which visits all left children, then the node itself, then all right children.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/searching/dijkstras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/dijkstras/</guid><description>Dijkstra&amp;rsquo;s Algorithm # One sentence overview: # Visit vertices in order of best-known distance from source; on visit relax every edge from the visited vertex.
Dijkstra&amp;rsquo;s vs BFS big idea: # BFS returns the shortest paths in an unweighted graph, where the shortest path is just defined to be the fewest number of edges traveled along a path. In Djikstras, we can generalize the breadth-first traversal to find the path with the lowest cost, where the cost is determined by different weights on the edges.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/searching/README/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/README/</guid><description>Searching # This section will cover some ways to find values in a set.
{% content-ref url=&amp;ldquo;binary-search.md&amp;rdquo; %} binary-search.md {% endcontent-ref %}
{% content-ref url=&amp;ldquo;depth-first-search-dfs.md&amp;rdquo; %} depth-first-search-dfs.md {% endcontent-ref %}
{% content-ref url=&amp;ldquo;breadth-first-search-bfs.md&amp;rdquo; %} breadth-first-search-bfs.md {% endcontent-ref %}</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/a-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/a-search/</guid><description>A* Search # {% hint style=&amp;ldquo;warning&amp;rdquo; %} In order to understand A*, you&amp;rsquo;ll need to review Dijkstra&amp;rsquo;s Algorithm first! Come back after you&amp;rsquo;re done with that ðŸ˜‰ {% endhint %}
A* Algorithm # The A* Search Algorithm is incredibly similar to Dijkstra&amp;rsquo;s Algorithm with one addition: a heuristic function.
This heuristic function calculates weights of a path from a vertex to a goal vertex. This way, we can help bias our algorithm in the right direction so that it doesnâ€™t make a bunch of bad moves.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/dijkstras-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/dijkstras-algorithm/</guid><description>Dijkstra&amp;rsquo;s Algorithm # {% hint style=&amp;ldquo;warning&amp;rdquo; %} Before continuing, make sure you&amp;rsquo;re comfortable with Graphs, Stacks and Queues, and Shortest Paths. {% endhint %}
One sentence overview # Visit vertices in order of best-known distance from source; on visit, relax every edge from the visited vertex.
Detailed Breakdown # Djikstras uses a PriorityQueue to maintain the path with lowest cost from the starting node to every other node, an edgeTo array to keep track of the best known predecessor for each vertex, and a distTo array to keep track of the best known distance from the source vertex to every other vertex.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/README/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/README/</guid><description>Shortest Paths # We&amp;rsquo;ve seen that Breadth-First Search can help us find the shortest path in an unweighted graph, where the shortest path was just defined to be the fewest number of edges traveled along a path. In the following shortest-paths algorithms, we will discover how we can generalize the breadth-first traversal to find the path with the lowest total cost, where the cost is determined by different weights on the edges.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/asymptotics/amortization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/asymptotics/amortization/</guid><description>Amortization # {% hint style=&amp;ldquo;warning&amp;rdquo; %} Please read Asymptotic Analysis Basics first. If you don&amp;rsquo;t, none of this will make any sense! {% endhint %}
Amortization means spreading out.
Sometimes, an operation takes different amounts of time for different values of $n$. Rather than having to report runtimes for each different case, we can instead average all of them out and report the amortized runtime.
This is especially good for functions where most actions have a low cost, but a few have a high cost.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/asymptotics/asymptotics-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/asymptotics/asymptotics-practice/</guid><description>Asymptotics Practice # {% hint style=&amp;ldquo;warning&amp;rdquo; %} Make sure to review Asymptotic Analysis Basics before proceeding with these problems. {% endhint %}
Introduction # Asymptotics is a very intuition-based concept that often doesn&amp;rsquo;t have a set algorithm for computing. The best way to get good at analyzing programs is to practice!
With that said, here are some problems of increasing difficulty for you to enjoy ðŸ˜Š
{% hint style=&amp;ldquo;info&amp;rdquo; %} For all of the below problems, assume that all undefined functions have a constant O(1) complexity.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/asymptotics/asymptotics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/asymptotics/asymptotics/</guid><description>Asymptotic Analysis Basics # {% hint style=&amp;ldquo;warning&amp;rdquo; %} This concept is a big reason why a strong math background is helpful for computer science, even when it&amp;rsquo;s not obvious that there are connections! Make sure you&amp;rsquo;re comfortable with Calculus concepts up to power series. {% endhint %}
An Abstract Introduction to Asymptotic Analysis # The term asymptotics, or asymptotic analysis, refers to the idea of analyzing functions when their inputs get really big.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/CS61B-Index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/CS61B-Index/</guid><description>Welcome # Welcome to 64bitpanda&amp;rsquo;s CS61B Guide! # (If you are looking at this in github, go to cs61b.bencuan.me for a much better experience!)
This is a non-comprehensive guide to data structures written with an intention to supplement learning and reviewing of Berkeley&amp;rsquo;s CS61B material. Main topics include:
Object oriented programming basics Abstract data types Asymptotics and runtime analysis Sorting algorithms Search algorithms And some more miscellaneous topics thrown in!</description></item><item><title/><link>https://notes.bencuan.me/cs61b/misc-topics/exceptions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/misc-topics/exceptions/</guid><description>Exceptions # Basics # An exception occurs when something unintended occurs and the interpreter must exit.
While this might sound like a bad thing, we can often throw our own exceptions to handle known errors or edge cases more gracefully.
Exceptions in Java # In Java, there are two types of exceptions: checked and unchecked.
Checked exceptions are handled during compile time, and are included in the method declaration.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/misc-topics/modular-arithmetic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/misc-topics/modular-arithmetic/</guid><description>Modular Arithmetic and Bit Manipulation # {% hint style=&amp;ldquo;warning&amp;rdquo; %} Make sure you&amp;rsquo;re comfortable working with binary numbers (adding, subtracting, converting to decimal) before continuing. {% endhint %}
Integer Types # This is an excerpt from the chart in Java Objects. Go there to review primitive types first!
Type Bits Signed Literals byte 8 yes 3, (int)17 short 16 yes None - must cast from int char 16 no &amp;lsquo;a&amp;rsquo;, &amp;lsquo;\n&amp;rsquo; int 32 yes 123, 0100 (octal), 0xff (hex) long 64 yes 123L, 0100L, 0xffL Signed Numbers # A type is signed if it can be positive or negative.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/misc-topics/more-resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/misc-topics/more-resources/</guid><description>More Resources # Here are some more cool things to look at!
Big O Cheat Sheet - complexities of sorting and common data structure operations Toptal Sorting Algorithm Animations - animations, pseudocode, and property summaries Josh Hug&amp;rsquo;s 61B Playlist - concise video lectures for most 61B topics Balanced Search Demos - play around with balanced search structures and see how they work</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/access-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/access-control/</guid><description>Access Control # What is Access Control? # In Java, we can specify the level of access certain variables and methods have. With this power, we can show or hide these variables to other classes and references on demand!
There are 4 modifier levels that get progressively more open:
Private: Only this class can see it. Package Protected (the default level): All classes in the same package can see it.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/dynamic-method-selection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/dynamic-method-selection/</guid><description>Dynamic Method Selection # {% hint style=&amp;ldquo;warning&amp;rdquo; %} This is a very tricky topic. Make sure you are comfortable with inheritance and access control before proceeding! {% endhint %}
Inheritance is great and all, but it does have some issues. One of the biggest issues lies in overriding: if two methods have exactly the same name and signature, which one do we call?
In a standard use case, this is a pretty simple answer: whichever one is in the class we want!</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/generics/</guid><description>Generic Types # Sometimes, we want things to support any type, including user defined types that we don&amp;rsquo;t know about! For example, it would make sense that we don&amp;rsquo;t care what type we make a List out of, since it&amp;rsquo;s just a whole bunch of objects put together.
The Java solution is generics! Generic types are denoted by a &amp;lt;&amp;gt; and can be appended to methods and classes. Here&amp;rsquo;s an example with classes:</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/inheritance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/inheritance/</guid><description>Inheritance # What is inheritance? # Essentially, it&amp;rsquo;s a way of putting similar objects together to generalize behavior. Inheritance is best used with relating subtypes to larger categories. For example, an :tangerine:orange is a fruit (so it&amp;rsquo;s a subtype of fruit).
Let&amp;rsquo;s say that a supermarket named Jrader Toe&amp;rsquo;s asks us to simulate fruits for them in an online system. We could do it like this:
Now, every fruit would need some of the same properties- like cost, weight, and name!</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/objects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/objects/</guid><description>Java Objects # There are two main categories of objects in Java: Primitive Types and Reference Types. This page will give a brief overview of both, and close off with some info about the mystical Object class.
Primitive Types # Primitive types are built in to Java and have fixed memory sizes. Different types require different amounts of memory.
If you remember environment diagrams, you may recall that some variables are put straight into the boxes, while others have an arrow pointing to them.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/sorting/sorting-basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/sorting/sorting-basics/</guid><description>Sorting # {% hint style=&amp;ldquo;info&amp;rdquo; %} For more information about specific sorting algorithms covered in 61B, see my guide on sorting that covers all of the sorts in far greater detail ðŸ™‚ {% endhint %}
Why sort? # It makes searching for a specific value much faster (e.g. binary search). Typically, searching through an unsorted list requires a full scan ($\Theta(N)$â€‹ runtime). It&amp;rsquo;s easy to see if two items in list are equal: just compare to see if any neighboring values are the same.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/SUMMARY/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/SUMMARY/</guid><description>Table of contents # Welcome Object Oriented Programming # Inheritance Access Control Dynamic Method Selection Java Objects Generic Types Asymptotics # Asymptotic Analysis Basics Amortization Asymptotics Practice Abstract Data Types # Collections Arrays Linked Lists Sets Stacks and Queues Binary Trees Heaps Balanced BSTs Tries Graphs Hashing and Hash Tables Union Find (Disjoint Sets) Comparables and Comparators Sorting # Sorting Algorithms # Minimax Algorithm Searching Binary Search Depth First Search (DFS) Breadth First Search (BFS) Shortest Paths Dijkstra&amp;rsquo;s Algorithm A* Search Minimum Spanning Trees Prim&amp;rsquo;s Algorithm Kruskal&amp;rsquo;s Algorithm Misc Topics # Modular Arithmetic and Bit Manipulation Exceptions More Resources</description></item></channel></rss>