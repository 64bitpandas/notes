<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome! on</title><link>https://notes.bencuan.me/</link><description>Recent content in Welcome! on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://notes.bencuan.me/cs61b/oop/inheritance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/inheritance/</guid><description>What is inheritance? # Essentially, it&amp;rsquo;s a way of putting similar objects together to generalize behavior. Inheritance is best used with relating subtypes to larger categories. For example, an :tangerine:orange is a fruit (so it&amp;rsquo;s a subtype of fruit).
Let&amp;rsquo;s say that a supermarket named Jrader Toe&amp;rsquo;s asks us to simulate fruits for them in an online system. We could do it like this:
Now, every fruit would need some of the same properties- like cost, weight, and name!</description></item><item><title>Asymptotic Analysis Basics</title><link>https://notes.bencuan.me/cs61b/asymptotics/asymptotics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/asymptotics/asymptotics/</guid><description>[!info] Content Note
This concept is a big reason why a strong math background is helpful for computer science, even when it&amp;rsquo;s not obvious that there are connections! Make sure you&amp;rsquo;re comfortable with Calculus concepts up to power series.
An Abstract Introduction to Asymptotic Analysis # The term asymptotics, or asymptotic analysis, refers to the idea of analyzing functions when their inputs get really big. This is like the asymptotes you might remember learning in math classes, where functions approach a value when they get very large inputs.</description></item><item><title>Dijkstra's Algorithm</title><link>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/dijkstras-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/dijkstras-algorithm/</guid><description>[!info] Content Note
Before continuing, make sure you&amp;rsquo;re comfortable with Graphs, Stacks and Queues, and Shortest Paths.
One sentence overview # Visit vertices in order of best-known distance from source; on visit, relax every edge from the visited vertex.
Detailed Breakdown # Djikstras uses a PriorityQueue to maintain the path with lowest cost from the starting node to every other node, an edgeTo array to keep track of the best known predecessor for each vertex, and a distTo array to keep track of the best known distance from the source vertex to every other vertex.</description></item><item><title>Kruskal's Algorithm</title><link>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/kruskals-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/kruskals-algorithm/</guid><description>[!info] Content Note
Before reading, review Minimum Spanning Trees and Union Find (Disjoint Sets) as they both make Kruskal&amp;rsquo;s algorithm possible!
Conceptual Overview # Kruskal&amp;rsquo;s algorithm is another optimal way to construct a minimum spanning tree. It&amp;rsquo;s benefits are that it is conceptually very simple, and easy to implement. The idea is that first we sort all the edges of the graph in order of increasing weight. Then, add the smallest edge to the MST we are constructing unless this creates a cycle in the MST.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/access-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/access-control/</guid><description>What is Access Control? # In Java, we can specify the level of access certain variables and methods have. With this power, we can show or hide these variables to other classes and references on demand!
There are 4 modifier levels that get progressively more open:
Private: Only this class can see it. Package Protected (the default level): All classes in the same package can see it. Protected: Subclasses (that inherit from the parent) can also see it.</description></item><item><title>Prim's Algorithm</title><link>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/prims-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/prims-algorithm/</guid><description>[!info] Content Note
Before reading, review Minimum Spanning Trees, as that is the foundation of Prim&amp;rsquo;s algorithm!
Conceptual Overview # Prim&amp;rsquo;s algorithm is an optimal way to construct a minimum spanning tree. It basically starts from an arbitrary vertex, then considers all its immediate neighbors and picks the edge with smallest weight to be part of the MST. Note: this creates a cut in the graph, where the two nodes in the MST being constructed are in one set, and every other vertex of the graph is in another set.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/dynamic-method-selection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/dynamic-method-selection/</guid><description>Dynamic Method Selection # [!warning] Content Note
This is a very tricky topic. Make sure you are comfortable with inheritance and access controlbefore proceeding!
Inheritance is great and all, but it does have some issues. One of the biggest issues lies in overriding: if two methods have exactly the same name and signature, which one do we call?
In a standard use case, this is a pretty simple answer: whichever one is in the class we want!</description></item><item><title>Java Objects</title><link>https://notes.bencuan.me/cs61b/oop/objects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/objects/</guid><description>There are two main categories of objects in Java: Primitive Types and Reference Types. This page will give a brief overview of both, and close off with some info about the mystical Object class.
Primitive Types # Primitive types are built in to Java and have fixed memory sizes. Different types require different amounts of memory.
If you remember environment diagrams, you may recall that some variables are put straight into the boxes, while others have an arrow pointing to them.</description></item><item><title>Generic Types</title><link>https://notes.bencuan.me/cs61b/oop/generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/generics/</guid><description>Sometimes, we want things to support any type, including user defined types that we don&amp;rsquo;t know about! For example, it would make sense that we don&amp;rsquo;t care what type we make a List out of, since it&amp;rsquo;s just a whole bunch of objects put together.
The Java solution is generics! Generic types are denoted by a &amp;lt;&amp;gt; and can be appended to methods and classes. Here&amp;rsquo;s an example with classes:</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/graphs/</guid><description>Introduction # Graphs are simply a collection of vertices connected by edges. They&amp;rsquo;re very similar to trees, but are much more versatile and don&amp;rsquo;t require hierarchical relationships like trees do.
For most purposes, we will be working with simple graphs that follow two rules:
There are no loops (a connection of a node to itself). There are no parallel edges (two edges that connect the same two vertices).</description></item><item><title>Hashing and Hash Tables</title><link>https://notes.bencuan.me/cs61b/abstract-data-types/hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/hashing/</guid><description>Data Indexed Sets: Introduction # So far, we&amp;rsquo;ve explored a whole bunch of ways we can store items, but they aren&amp;rsquo;t really optimized for general searching. What if we could get searching in $\Theta(1)$ time??? Wouldn&amp;rsquo;t that be nice!
Let&amp;rsquo;s try something: putting all of our data in a massive array. Let&amp;rsquo;s say that we know all our data falls into the range from 0 to 10,000 and make an array of 10,000 length to hold stuff.</description></item><item><title>Union Find (Disjoint Sets)</title><link>https://notes.bencuan.me/cs61b/abstract-data-types/union-find-disjoint-sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/union-find-disjoint-sets/</guid><description>Union Find (Disjoint Sets) # [!info] Content Note
This is not a complete entry, because I feel like existing course materials already cover this in an extremely intuitive manner. See lab 14 for an guide on how to implement your own Union Find structure!
The Union Find data structure is a way of representing a bunch of nodes that are connected to each other in subsets. It&amp;rsquo;s used in Kruskal&amp;rsquo;s Algorithm among other things.</description></item><item><title>Sorting</title><link>https://notes.bencuan.me/cs61b/algorithms/sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/sorting/</guid><description>[!important] Sorting Guide
For more information about specific sorting algorithms covered in 61B, see my guide on sorting that covers all of the sorts in far greater detail 🙂
Why sort? # It makes searching for a specific value much faster (e.g. binary search). Typically, searching through an unsorted list requires a full scan ($\Theta(N)$​ runtime). It&amp;rsquo;s easy to see if two items in list are equal: just compare to see if any neighboring values are the same.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/comparables-and-comparators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/comparables-and-comparators/</guid><description>What is it? # A Comparable is a generic type that allows standardized comparisons between objects.
In other words, anything that has a compareTo() method can be a Comparable!
Many Java libraries already use Comparable without you knowing! Some of the more well-known ones are Collection and String.
CompareTo can&amp;rsquo;t return anything you want! # There are some very specific properties CompareTo needs to have! Usually, we take them for granted but might forget about them when making our own.</description></item><item><title>A* Search</title><link>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/a-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/a-search/</guid><description>[!info] Content Note
In order to understand A*, you&amp;rsquo;ll need to be comfortable Dijkstra&amp;rsquo;s Algorithm first!
A* Algorithm # The A* Search Algorithm is incredibly similar to Dijkstra&amp;rsquo;s Algorithm with one addition: a heuristic function.
This heuristic function calculates weights of a path from a vertex to a goal vertex. This way, we can help bias our algorithm in the right direction so that it doesn’t make a bunch of bad moves.</description></item><item><title>Minimax Algorithm</title><link>https://notes.bencuan.me/cs61b/algorithms/minimax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimax/</guid><description>Game Trees # The Minimax algorithm is often used for making AI&amp;rsquo;s for turn-based games. It relies on the use of a type of game tree, which maps out all of the possible moves that players can make.
In the tree, there are two types of nodes: maximizing nodes and minimizing nodes. The max-nodes represent you- you want to make your position as advantageous as possible (maximizing your score). The min-nodes represent your opponent- they want to make you do as poorly as possible (minimizing your score).</description></item><item><title/><link>https://notes.bencuan.me/cs186/00-SQL-Basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/00-SQL-Basics/</guid><description>SQL Basics # Relational Terminology # Database: a set of named relations Relation: a table Schema: description (metadata) Fixed, with unique attribute names and atomic types (integers, text, etc.) Instance: the set of data that satisfies the schema Often changes, and can contain a multiset of tuples Attribute (column): a field Tuple (row): one record SQL Introduction # SQL is a relational database language that consists of two sub-languages:</description></item><item><title/><link>https://notes.bencuan.me/cs186/01-Disks-Buffers-Files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/01-Disks-Buffers-Files/</guid><description>Disks, Buffers, Files # Devices # Hierarchy:
Page = Block = atomic unit for disk IO (can’t write a fractional page)
Sequential runs are assumed to be fast.
HDD # Hard drives are magnetic disks that contain tracks of data around a cylinder.
HDD&amp;rsquo;s are generally good for sequential reading, but bad for random reads.
Disk Latency = Queueing Time + Controller Time + Seek Time + Rotation Time + Transfer Time</description></item><item><title/><link>https://notes.bencuan.me/cs186/02-Cost-Analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/02-Cost-Analysis/</guid><description>Cost Analysis # In order to make efficient queries, we need a measure of how good or fast a query is. Knowing that queries operate on records, which are stored on pages in a file on disk, we can use the following cost model for analysis:
$B$ = number of data blocks in file $R$ = number of records per block $D$ = average time to read or write disk block For analysis, we will use the following assumptions:</description></item><item><title/><link>https://notes.bencuan.me/cs186/03-B+-Trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/03-B+-Trees/</guid><description>B+ Trees # The Representation # Main idea: a search tree with a high branch factor. (Lower depth = faster runtime!)
Recursively index the key file such that: Great than or equal to index: Go to the right Less than the index: Go to the left All entries within each node are sorted.
Occupancy Invariant # The order of the tree, $d$, is defined such that each interior node is at least partially full:</description></item><item><title/><link>https://notes.bencuan.me/cs186/04-Sorting-and-Hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/04-Sorting-and-Hashing/</guid><description>Sorting and Hashing # When dealing with disk operations, traditional sorting algorithms tend to create lots of random accesses and can be quite slow. We’ll explore a few strategies for creating optimized algorithms for sorting databases.
Single-Pass Streaming # Single-pass streaming is an approach for mapping inputs to their desired outputs while minimizing memory and disk usage.
Main idea: There are two buffers (input and output). Continuously read from the input buffer and convert them into outputs to place in the output buffer.</description></item><item><title/><link>https://notes.bencuan.me/cs186/05-Iterators-and-Joins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/05-Iterators-and-Joins/</guid><description>Iterators and Joins # Cost Notation # Used to analyze the size of a database.
$R$ is a table.
$[R]$ is the number of pages needed to store $R$
$p_R$ is the number of records per page of $R$.
$|R|$ is the cardinality of $R$, or the number of records.
$|R| = p_R \times [R]$ Simple Join # Intuitively, joining two tables is essentially a double for loop over the records in each table:</description></item><item><title/><link>https://notes.bencuan.me/cs186/06-Relational-Algebra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/06-Relational-Algebra/</guid><description>Relational Algebra # Relational algebra is a language that represents a logical query plan for translating SQL queries into underlying actions.
perform operations on sets (the “how”) operational description of transformations Related to relational calculus (which describes the result of a computation: the “what”) by Codd’s Theorem: everything that can be represented with relational calculus can be equivalently represented in relational algebra Operators # Unary Operators # Unary operators work on a single relation.</description></item><item><title/><link>https://notes.bencuan.me/cs186/07-Query-Optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/07-Query-Optimization/</guid><description>Query Optimization # Query optimization is the bridge between a declarative language (like SQL, where you describe “what” you want) and an imperative language (like Java, which describes how the answer is actually computed).
System R Optimizers # The query parser first checks for correctness and authorization (user permissions to access the table). It then generates a parse tree out of the query. This step is usually fairly straightforward.</description></item><item><title/><link>https://notes.bencuan.me/cs186/08-Transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/08-Transactions/</guid><description>Transactions # Transactions are collections of operations that can be treated like a single unit.
ACID and Concurrency # We want all transactions to obey ACID:
Atomicity: either all operations happen, or none of them Consistency: database remains in a consistent state with its constraints Isolation: it should appear as if we only run 1 transaction at a time (even if they’re actually run concurrently) Durability: once a transaction commits, it persists Transaction operations:</description></item><item><title/><link>https://notes.bencuan.me/cs186/09-Parallel-Query-Processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/09-Parallel-Query-Processing/</guid><description>Parallel Query Processing # Parallelism helps us break down a big problem into small, independent chunks. The idea is that a lot of machines all working on the same problem at the same time will finish the problem more quickly.
There are two main metrics we want:
Speed-up: if we add more hardware, the same workload should be completed more quickly. Scale-up: if the workload increases, we should be able to add a corresponding amount of hardware to make the problem be processed with the same amount of time as before.</description></item><item><title/><link>https://notes.bencuan.me/cs186/10-Recovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/10-Recovery/</guid><description>Recovery # Recovery is the process of making databases resilient to failure. Specifically, recovery enforces durability (a committed transaction remains persistent) and atomicity (either all of the operations in a transaction complete, or none of them).
Assumptions:
We use strict two-phase locking for concurrency control. Updates happen in-place: transactions that modify data overwrite entries in the database. Steal/No Force # No Steal Policy # Don’t allow buffer pool frames with uncommitted updates to be replaced or flushed to disk.</description></item><item><title/><link>https://notes.bencuan.me/cs186/11-Distributed-Transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/11-Distributed-Transactions/</guid><description>Distributed Transactions # If
2 Phase Commit # Phase 1: voting
Coordinator asks participants to vote by sending a PREPARE message to all participants. Participants send VOTE YES or VOTE NO to coordinator. Participants log and flush either a PREPARE or ABORT record to the log, keeping track of the coordinator ID. After the coordinator receives a message from all participants, the coordinator logs and flushes either a COMMIT or ABORT record to log Phase 2: results</description></item><item><title/><link>https://notes.bencuan.me/cs186/12-ER-Diagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/12-ER-Diagrams/</guid><description>ER Diagrams # Production databases have a lot of tables with complicated relationships. Entity Relationship (ER) Diagrams help us organize databases in a visual manner.
Steps in Database Design # Requirement Analysis: what do users need the database to do? Conceptual Design (ER Model): highly level description of DB schemas Logical Design: translate ER model into DBMS data model Schema Refinement: consistency, normalization Physical Design: indices, disk layout Security Design: who accesses what, and how Data Models # A data model is a collection of concepts for describing data.</description></item><item><title/><link>https://notes.bencuan.me/cs186/13-Extras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/13-Extras/</guid><description>Extras # Databases at Uber # Postgres # Postgres is a popular open-source SQL relational DBMS that supports:
ACID transactions B-tree with indices Query optimization Parallelization Write-ahead logging Replication PostGIS geospatial support Some properties of Postgres:
Tuples are immutable, so we need to create a new version of a row every time we update it. All rows contain a version ID and a pointer the previous version.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/balanced-search-structures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/balanced-search-structures/</guid><description>[!info] Content Note
Please read Binary Trees before continuing!
Balanced Binary Search Trees are an even more specific subcategory of binary trees that have an important property: they are always bushy.
B Trees (2-4 Trees) # The basic idea: Nodes can hold multiple values now! When nodes have too many values, we will split it.
A 2-4 tree is named such because each parent can have 2 to 4 children.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/heaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/heaps/</guid><description>What are Heaps? # A heap is a specific order of storing data, often in a list. Heaps are very similar to binary trees, but have some differences:
Unlike trees, heaps only care about the root node. Usually, the root node is either the largest or smallest value in the heap (corresponding with max-heaps and min-heaps), and we don&amp;rsquo;t care too much about the rest. Every element in the heap must be larger than all its children (in a max-heap) or smaller than all its children (in a min-heap).</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/tries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/tries/</guid><description>Main Ideas # A trie is a specific implementation of a set and is short for retrieval tree.
It only works on sets with a finite alphabet, like digits or ASCII characters, for example. The idea is that each node can act like an array containing all characters in the alphabet and we can just access the branches super fast by indexing into them!
Tries are fantastic for searching to see if a word is contained in a set.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/arrays/</guid><description>[!info] Content Note
This page assumes prior knowledge of Python lists from CS61A or equivalent.
Arrays are a very popular data structure that stores an indexed list of data.
Properties # Fixed length: after instantiation, the length of an array cannot be changed. Every value in array is the same type and holds the same amount of bits in memory. Zero-indexed. That means arr[0] returns the first value, and arr[arr.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/linked-lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/linked-lists/</guid><description>[!info] Content Note
This page assumes prior knowledge of linked lists from CS61A or equivalent. I&amp;rsquo;ll assume you have already worked with basic singly linked lists before.
The linked list is an extremely common recursive data structure that allows storage and access of an arbitrary amount of data.
Feature List of an Effective Linked List # Rebranding- represents Node as an individual object rather than having one monolithic List type.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/sets/</guid><description>[!warning] Warning
This page is incomplete. help make it better!
Basics # A Set stores a collection of values with no duplicates. Sets have no inherent order, so you can&amp;rsquo;t rely on expecting any value to come before any other value when iterating through them.
Some set functions include:
add(T x) contains(T x) size() ArraySet # An ArraySet is an array-based solution to a set implementation.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/stacks-and-queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/stacks-and-queues/</guid><description>Stacks and queues are two very common data structures used for a variety of applications from CPU processes to finding shortest paths using Dijkstra&amp;rsquo;s Algorithm. Fundamentally, they are very similar in structure and only differ by the order in which items are popped from them.
Pushing and Popping # Pushing # Adding an item to a stack or queue is called pushing. This will either put the item on the top of a stack or in the back of a queue.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/searching/binary-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/binary-search/</guid><description>Binary Search # Binary search is a way of finding a specific node in a tree. It only works on binary trees due to its helpful sorted property. It simply traverses the tree, moving left if the current node is too large or right if it is too small.
Binary search runs in $\Theta(\log(n))$ time for bushy trees, which is also the number of layers in a tree.
The Algorithm # public BST find(BST T, Key sk) { if (T == null) { return null; } if (sk.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/asymptotics/amortization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/asymptotics/amortization/</guid><description>Amortization # [!info] Content Note
Please read Asymptotic Analysis Basics first. If you don&amp;rsquo;t, none of this will make any sense!
Amortization means spreading out.
Sometimes, an operation takes different amounts of time for different values of $n$. Rather than having to report runtimes for each different case, we can instead average all of them out and report the amortized runtime.
This is especially good for functions where most actions have a low cost, but a few have a high cost.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/asymptotics/asymptotics-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/asymptotics/asymptotics-practice/</guid><description>Asymptotics Practice # [!info] Content Note
Make sure to review Asymptotic Analysis Basics before proceeding with these problems.
Introduction # Asymptotics is a very intuition-based concept that often doesn&amp;rsquo;t have a set algorithm for computing. The best way to get good at analyzing programs is to practice!
With that said, here are some problems of increasing difficulty for you to enjoy 😊
[!hint] Read before you do the problems!</description></item><item><title/><link>https://notes.bencuan.me/cs61b/misc-topics/exceptions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/misc-topics/exceptions/</guid><description>Exceptions # Basics # An exception occurs when something unintended occurs and the interpreter must exit.
While this might sound like a bad thing, we can often throw our own exceptions to handle known errors or edge cases more gracefully.
Exceptions in Java # In Java, there are two types of exceptions: checked and unchecked.
Checked exceptions are handled during compile time, and are included in the method declaration.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/misc-topics/modular-arithmetic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/misc-topics/modular-arithmetic/</guid><description>Modular Arithmetic and Bit Manipulation # {% hint style=&amp;ldquo;warning&amp;rdquo; %} Make sure you&amp;rsquo;re comfortable working with binary numbers (adding, subtracting, converting to decimal) before continuing. {% endhint %}
Integer Types # This is an excerpt from the chart in Java Objects. Go there to review primitive types first!
Type Bits Signed Literals byte 8 yes 3, (int)17 short 16 yes None - must cast from int char 16 no &amp;lsquo;a&amp;rsquo;, &amp;lsquo;\n&amp;rsquo; int 32 yes 123, 0100 (octal), 0xff (hex) long 64 yes 123L, 0100L, 0xffL Signed Numbers # A type is signed if it can be positive or negative.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/misc-topics/more-resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/misc-topics/more-resources/</guid><description>More Resources # Here are some more cool things to look at!
Big O Cheat Sheet - complexities of sorting and common data structure operations Toptal Sorting Algorithm Animations - animations, pseudocode, and property summaries Josh Hug&amp;rsquo;s 61B Playlist - concise video lectures for most 61B topics Balanced Search Demos - play around with balanced search structures and see how they work</description></item><item><title>Breadth First Search (DFS)</title><link>https://notes.bencuan.me/cs61b/algorithms/searching/breadth-first-search-bfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/breadth-first-search-bfs/</guid><description>Breadth First Search (BFS), like Depth First Search (DFS), is a method of traversing a graph. BFS simply traverses in a different order, but otherwise is very similar to DFS.
The main difference is that BFS visits all children before any subgraphs. In a tree, we call this level order.
For the example tree above, a level order traversal would go in this order: D B F A C E G.</description></item><item><title>Contributing</title><link>https://notes.bencuan.me/contributing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/contributing/</guid><description>Thanks for your interest in contributing to my notes! There&amp;rsquo;s a lot of room for improvement, and I don&amp;rsquo;t have the time to fix everything. If there&amp;rsquo;s something that you&amp;rsquo;d like to add, please do so!
Making Requests # I use GitHub for issue tracking. Please make an issue before editing anything or creating a pull request, so I can comment on it before you start working on a feature.</description></item><item><title>Depth First Search (DFS)</title><link>https://notes.bencuan.me/cs61b/algorithms/searching/depth-first-search-dfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/depth-first-search-dfs/</guid><description>Depth First Traversal # Before we move on to searching, let&amp;rsquo;s talk about traversing. Traversal is the act of visiting nodes in a specific order. This can be done either in trees or in graphs.
For trees in particular, there are three main ways to traverse.
The first way is inorder traversal, which visits all left children, then the node itself, then all right children. The end result should be that the nodes were visited in sorted order.</description></item></channel></rss>