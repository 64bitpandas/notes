<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome! on</title><link>https://notes.bencuan.me/</link><description>Recent content in Welcome! on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://notes.bencuan.me/cs70/probability/probability-overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/probability/probability-overview/</guid><description>The probability section of this guide will likely never be fully completed, due to the fact that the Prob 140 textbook is such an excellent resource in probability theory. Go read it and do the problems!
Instead of a full write-up, the pages in this section will typically just link to relevant sections from the textbook. Personally, I found everything I needed to do well in CS70 probability (and much more) here, including examples that are very similar to problems you might see on the homework.</description></item><item><title>Discrete Math Overview</title><link>https://notes.bencuan.me/cs70/discrete-math/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/overview/</guid><description>What even is discrete math? # According to Wikipedia, &amp;ldquo;Discrete mathematics is the study of mathematical structures that are fundamentally discrete rather than continuous.&amp;rdquo; Very helpful, thank you Wikipedia. The floor is indeed made of floor rather than sky.
The word discrete means &amp;ldquo;distinct&amp;rdquo; or &amp;ldquo;countable&amp;rdquo;. This suggests that discrete math has to do with countable numbers like integers, rather than the continuous $f(x)$functions we&amp;rsquo;re used to seeing that are defined for any real$x$, even ones we don&amp;rsquo;t know the exact value of like $\pi$.</description></item><item><title>Overview</title><link>https://notes.bencuan.me/cs61a/introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61a/introduction/</guid><description>Introduction # Being the largest course at Berkeley, CS 61A has a lot of existing resources- not to mention John DeNero&amp;rsquo;s recorded lectures are everything you could ever hope for in a lecture. I just don&amp;rsquo;t see how I could contribute any meaningful content note that hasn&amp;rsquo;t been done extremely well multiple times already.
Instead, I want to make a space where you can more easily find all of those resources, share some thoughts about my time TAing for 61A, and provide some dialogue about critical skills not taught in 61A but are necessary for succeeding in the CS major and software engineering.</description></item><item><title>What is an I/O and why should I care?</title><link>https://notes.bencuan.me/cs186/io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/io/</guid><description>If you&amp;rsquo;re taking 186, you&amp;rsquo;ve probably heard or experienced some variation of the following:
This class has a lot of I/O counting on exams I/Os are weird, sometimes you can read like 5 things at the same time but it&amp;rsquo;s still one I/O for some reason I/O counting is tedious and boring and I will never do it after this class, so why do I need to do it?????? While I can&amp;rsquo;t guarantee that you&amp;rsquo;ll ever count I/Os after this class, my hope for this article is to justify why it&amp;rsquo;s necessary for understanding key database design concepts, and how the principles can be applied to real-world issues in query optimization.</description></item><item><title/><link>https://notes.bencuan.me/cs168/intro-to-the-internet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/intro-to-the-internet/</guid><description>About this Class # There are two meanings of internet:
the infrastructure that connects computing devices, or the ecosystem of applications built on that infrastructure. When the average person says &amp;ldquo;internet&amp;rdquo; they usually refer to the second definition. This class, on the other hand, explores the first.
Why study the internet? It&amp;rsquo;s one of the most impactful and life-changing inventions in human history. In addition, it&amp;rsquo;s too large and complex for theoretical models and requires an entirely new design paradigm of:</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/inheritance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/inheritance/</guid><description>What is inheritance? # Essentially, it&amp;rsquo;s a way of putting similar objects together to generalize behavior. Inheritance is best used with relating subtypes to larger categories. For example, an :tangerine:orange is a fruit (so it&amp;rsquo;s a subtype of fruit).
Let&amp;rsquo;s say that a supermarket named Jrader Toe&amp;rsquo;s asks us to simulate fruits for them in an online system. We could do it like this:
Now, every fruit would need some of the same properties- like cost, weight, and name!</description></item><item><title>Asymptotic Analysis Basics</title><link>https://notes.bencuan.me/cs61b/asymptotics/asymptotics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/asymptotics/asymptotics/</guid><description>[!info] Content Note
This concept is a big reason why a strong math background is helpful for computer science, even when it&amp;rsquo;s not obvious that there are connections! Make sure you&amp;rsquo;re comfortable with Calculus concepts up to power series.
An Abstract Introduction to Asymptotic Analysis # The term asymptotics, or asymptotic analysis, refers to the idea of analyzing functions when their inputs get really big. This is like the asymptotes you might remember learning in math classes, where functions approach a value when they get very large inputs.</description></item><item><title>Dijkstra's Algorithm</title><link>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/dijkstras-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/dijkstras-algorithm/</guid><description>[!info] Content Note
Before continuing, make sure you&amp;rsquo;re comfortable with Graphs, Stacks and Queues, and Shortest Paths.
One sentence overview # Visit vertices in order of best-known distance from source; on visit, relax every edge from the visited vertex.
Detailed Breakdown # Djikstras uses a PriorityQueue to maintain the path with lowest cost from the starting node to every other node, an edgeTo array to keep track of the best known predecessor for each vertex, and a distTo array to keep track of the best known distance from the source vertex to every other vertex.</description></item><item><title>Kruskal's Algorithm</title><link>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/kruskals-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/kruskals-algorithm/</guid><description>[!info] Content Note
Before reading, review Minimum Spanning Trees and Union Find (Disjoint Sets) as they both make Kruskal&amp;rsquo;s algorithm possible!
Conceptual Overview # Kruskal&amp;rsquo;s algorithm is another optimal way to construct a minimum spanning tree. It&amp;rsquo;s benefits are that it is conceptually very simple, and easy to implement. The idea is that first we sort all the edges of the graph in order of increasing weight. Then, add the smallest edge to the MST we are constructing unless this creates a cycle in the MST.</description></item><item><title>SQL Basics</title><link>https://notes.bencuan.me/cs186/00-SQL-Basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/00-SQL-Basics/</guid><description>Relevant Materials # Note 1 Note 2 Discussion 1 What is SQL? # Structured Query Language (/ˈsiːkwəl/) is a highly standardized syntax for performing operations on a database.
Terminology # SQL databases are a set of named relations, or tables, that describe the relationship between attributes. You can think of attributes as the columns of the table, and each record (also known as a tuple) being one row in the table.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/access-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/access-control/</guid><description>What is Access Control? # In Java, we can specify the level of access certain variables and methods have. With this power, we can show or hide these variables to other classes and references on demand!
There are 4 modifier levels that get progressively more open:
Private: Only this class can see it. Package Protected (the default level): All classes in the same package can see it. Protected: Subclasses (that inherit from the parent) can also see it.</description></item><item><title>Prim's Algorithm</title><link>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/prims-algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimum-spanning-trees/prims-algorithm/</guid><description>[!info] Content Note
Before reading, review Minimum Spanning Trees, as that is the foundation of Prim&amp;rsquo;s algorithm!
Conceptual Overview # Prim&amp;rsquo;s algorithm is an optimal way to construct a minimum spanning tree. It basically starts from an arbitrary vertex, then considers all its immediate neighbors and picks the edge with smallest weight to be part of the MST. Note: this creates a cut in the graph, where the two nodes in the MST being constructed are in one set, and every other vertex of the graph is in another set.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/oop/dynamic-method-selection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/dynamic-method-selection/</guid><description>Dynamic Method Selection # [!warning] Content Note
This is a very tricky topic. Make sure you are comfortable with inheritance and access controlbefore proceeding!
Inheritance is great and all, but it does have some issues. One of the biggest issues lies in overriding: if two methods have exactly the same name and signature, which one do we call?
In a standard use case, this is a pretty simple answer: whichever one is in the class we want!</description></item><item><title>Java Objects</title><link>https://notes.bencuan.me/cs61b/oop/objects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/objects/</guid><description>There are two main categories of objects in Java: Primitive Types and Reference Types. This page will give a brief overview of both, and close off with some info about the mystical Object class.
Primitive Types # Primitive types are built in to Java and have fixed memory sizes. Different types require different amounts of memory.
If you remember environment diagrams, you may recall that some variables are put straight into the boxes, while others have an arrow pointing to them.</description></item><item><title>Generic Types</title><link>https://notes.bencuan.me/cs61b/oop/generics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/oop/generics/</guid><description>Sometimes, we want things to support any type, including user defined types that we don&amp;rsquo;t know about! For example, it would make sense that we don&amp;rsquo;t care what type we make a List out of, since it&amp;rsquo;s just a whole bunch of objects put together.
The Java solution is generics! Generic types are denoted by a &amp;lt;&amp;gt; and can be appended to methods and classes. Here&amp;rsquo;s an example with classes:</description></item><item><title>LaTeX Reference</title><link>https://notes.bencuan.me/cs70/latex-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/latex-reference/</guid><description># Basics # Symbol Description LaTeX $\cdot$ Multiplication dot \cdot $\cdots$ Dots \cdots $\frac{x}{y}$ Fraction \frac{x}{y} $\ge$ Greater than or equal to \ge $\le$ Less than or equal to \le $\ne$ Not equal to \ne $\sum_{i=0}^{n}$ Summation \sum_{i=0}^{n} $\infty$ Infinity \infty $\lim_{x \to \infty}$ Limit \lim_{x \to \infty} Propositional Logic # Symbol Description LaTeX $\implies$ Implication \implies $\iff$ Logical equivalence \iff $\equiv$ Congruence \equiv $\exists$ Existence \exists $\in$ Inclusion \in $\land$ Conjunction (and) \land $\lor$ Disjunction (or) \lor $\lnot$ Negation (not) \lnot $\forall$ For all \forall $\oplus$ Exclusive or (xor) \oplus Sets # Symbol Description LaTeX $\mathbb{C}$ Complex numbers \mathbb{C} $\mathbb{R}$ Real numbers \mathbb{R} $\mathbb{Q}$ Rational numbers \mathbb{Q} $\mathbb{Z}$ Integers \mathbb{Z} $\mathbb{N}$ Natural numbers \mathbb{N} $\mathscr{P}$ Power set \mathscr{P} $\cup$ Union (set or) \cup $\cap$ Intersection (set and) \cap $\emptyset$ Empty Set \emptyset $\setminus$ Set Division \setminus $\subseteq$ Subset (inclusive) \subseteq Modular Arithmetic # Symbol Description LaTeX $p \mod q$ Modulo \mod $p \pmod{q}$ Modulo in parentheses \pmod{q}</description></item><item><title/><link>https://notes.bencuan.me/cs70/probability/counting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/probability/counting/</guid><description>Introduction # If you&amp;rsquo;re reading this, I think it&amp;rsquo;s safe to assume you already know how to count&amp;hellip; (1, 2, 3, whatever) so what&amp;rsquo;s the big deal about counting?
When we say counting in this context, we mean counting sequences of decisions. For example, we might want to get the total number of ways to choose toppings on a pizza or something.
There are two main types of problems: those where order matters and those where it doesn&amp;rsquo;t.</description></item><item><title/><link>https://notes.bencuan.me/data102/binary-decision-making/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/binary-decision-making/</guid><description>Binary Decision Making is the simplest kind of decision we can make: 1 or 0, yes or now, true or false&amp;hellip;
Setup # In reality, a value is either 0 or 1. However, we observe noisy data that isn&amp;rsquo;t always 100% accurate. Given this noisy data, we make a decision (also either 0 or 1).
Some examples of binary decisions are:
COVID testing (positive or negative) Fraud detection (fraud or no fraud) Confusion Matrix # A 2x2 table that helps us evaluate how effective our predictions were (columns) given reality (rows).</description></item><item><title>Disks, Buffers, and Files</title><link>https://notes.bencuan.me/cs186/01-Disks-Buffers-Files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/01-Disks-Buffers-Files/</guid><description>Relevant Materials # Note 3 Discussion 2 Introduction # Now that we&amp;rsquo;ve taken a look at how humans can interface with databases using SQL, let&amp;rsquo;s jump all the way down to the bottom and lay the foundations for how we can go from individual bytes to a fully functional database!
Before reading this section, review the page What is an I/O and why should I care?</description></item><item><title/><link>https://notes.bencuan.me/cs70/probability/discrete-probability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/probability/discrete-probability/</guid><description>Probability Basics # http://prob140.org/textbook/content/Chapter_02/00_Calculating_Chances.html
Adding and subtracting probabilities - Multiplying probabilities: random draws without replacement, conditional probabilities Bayes&amp;rsquo; Rule # Bayes&amp;rsquo; Rule is used to re-express conditional probabilities $P(A|B)$.
http://prob140.org/textbook/content/Chapter_02/05_Updating_Probabilities.html#bayes-rule
Random Variables # Probability Spaces # Probability spaces describe all of the possible values of a random variable, and how likely each of those outcomes are.
http://prob140.org/textbook/content/Chapter_02/00_Calculating_Chances.html
Equality # Two variables are equal if $X(\omega) = Y(\omega)$ for all $\omega \in \Omega$, where $\Omega$ is a probability space (all possible values).</description></item><item><title/><link>https://notes.bencuan.me/data102/hypothesis-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/hypothesis-testing/</guid><description>Hypothesis Testing # Hypothesis testing is a form of [[binary decision making]] (do we accept or reject the null hypothesis?).
Formulate null hypothesis, alternate hypothesis, and test statistic Compute value of test statistic based on data Simulate test statistic under null hypothesis many times Compare results to determine likelihood of result As an example of how this relates to binary decision making:
Null hypothesis true: reality = 0 Alternative hypothesis true: reality = 1 Fail to reject null: decision = 0 Reject null: decision = 1 So if the null hypothesis is actually true but we end up rejecting it, then a false positive result has occurred.</description></item><item><title>B+ Trees</title><link>https://notes.bencuan.me/cs186/02-B+-Trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/02-B+-Trees/</guid><description>Relevant Materials # Note 4 Discussion 3: view this for B+ tree algorithm walkthroughs! Introduction # B+ Trees are one type of index: a data structure that allows for quick lookups based on a particular key. They are very similar to binary trees, but can have more than two pointers and come with a variety of improvements.
What is an index exactly? # We can index a collection on any ordered subset of columns.</description></item><item><title>Networking Command Line Tools</title><link>https://notes.bencuan.me/cs168/cli/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/cli/</guid><description>nslookup # Resolves a hostname to an IP address (or the reverse).
Basic usage: nslookup &amp;lt;hostname&amp;gt; &amp;lt;DNS server&amp;gt;
Example: ❯ nslookup cs168.io Server: 127.0.0.53 Address: 127.0.0.53#53 Non-authoritative answer: Name: cs168.io Address: 185.199.109.153 Name: cs168.io Address: 185.199.110.153 Name: cs168.io Address: 185.199.111.153 Name: cs168.io Address: 185.199.108.153 Reverse lookup: nslookup &amp;lt;ip&amp;gt;
❯ nslookup 185.199.110.153 153.110.199.185.in-addr.arpa name = cdn-185-199-110-153.github.com. host # Used for DNS lookup (converting between IP addresses and domain names).</description></item><item><title/><link>https://notes.bencuan.me/cs70/probability/hashing-and-the-union-bound/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/probability/hashing-and-the-union-bound/</guid><description>A hash function assigns a value to each member in a set. It&amp;rsquo;s often useful to determine the probability of collisions: where two different items are assigned the same hash value.
http://prob140.org/textbook/content/Chapter_01/03_Collisions_in_Hashing.html
An interesting result is explored by the Birthday Problem (sometimes known as the Birthday Paradox, despite not actually being paradoxical), in which the probability of at least two people sharing the same birthday is much higher than expected.</description></item><item><title/><link>https://notes.bencuan.me/data102/decision-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/decision-theory/</guid><description>So far, in [[binary decision making]] and [[hypothesis testing]], we&amp;rsquo;ve explored how to make as few mistakes as possible when making binary predictions.
Intro to Decision Theory # We can generalize a decision problem to the following:
Suppose there is some unknown quantity of interest $\theta$. $\theta$ is random under a Bayesian approach, and fixed if frequentist. We collect/observe some data $X$. There is some true distribution that the data is drawn from, $p(X | \theta)$.</description></item><item><title>Buffer Management</title><link>https://notes.bencuan.me/cs186/03-Buffer-Management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/03-Buffer-Management/</guid><description>Introduction # So far, we&amp;rsquo;ve established the fact that the disk is slow, and memory is fast- and that one of the biggest challenges in database implementation is in minimizing the number of times we need to incur I/Os by transferring data in between disk and memory.
Since memory is limited, we need to figure out a clever way to re-use information once it&amp;rsquo;s read into memory, while still allowing new information to come in when needed.</description></item><item><title>Introduction to Routing</title><link>https://notes.bencuan.me/cs168/intradomain-routing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/intradomain-routing/</guid><description>Addressing and Naming # In the real world, people have names and are located at addresses. When we move around, our name stays the same, but our address changes.
The internet works in a very similar manner. Hosts have a network name (which describes which host it is) and a network address (where the host is currently located).
Conceptual Intro to Routing # First, we&amp;rsquo;ll run a distributed routing algorithm between switches and routers.</description></item><item><title/><link>https://notes.bencuan.me/cs168/measuring-link-performance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/measuring-link-performance/</guid><description>Some values # The Bandwidth of a link is the number of bits sent/received per unit time (measured in bps, bits per second).
The Propagation delay of a link is the time it takes a bit to travel along the link (measured in seconds). It is analogous to the &amp;rsquo;length&amp;rsquo; of the link.
Bandwidth-delay product (BDP) is the product of bandwidth and propagation delay, measured in bits. It is analogous to the total capacity of a link (how many bits can be in the link at the same time).</description></item><item><title/><link>https://notes.bencuan.me/cs70/probability/expectation-and-variance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/probability/expectation-and-variance/</guid><description>The expectation of a random variable, $E(X)$, is the average of possible values weighted by their probabilities. Formally, it can be defined in two ways:
Domain definition: $E(X) = \sum_{\omega \in \Omega} X(\omega) P(\omega)$. Range definition: $E(X) = \sum_x x P(X = x)$. Expectation has nice properties of linearity: $E(X + Y) = E(X) + E(Y)$ and $E(aX + b) = aE(x) + b$.
http://prob140.org/textbook/content/Chapter_08/01_Definition.html</description></item><item><title/><link>https://notes.bencuan.me/data102/parameter-estimation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/parameter-estimation/</guid><description>Suppose we observe $n$ data points ($x_1$ to $x_n$). Let $\theta$ be some unknown parameter that describes the distribution the data points were sampled from.
As an example, let&amp;rsquo;s say we are trying to quantify how good a product is based on how many positive and negative reviews it has.
This means that data $x_i$ is either $0$ (bad review) or $1$ (good review) Let $p(x_i | \theta) = \theta^{x_i} (1-\theta)^{1-x_i}$.</description></item><item><title>Sorting and Hashing</title><link>https://notes.bencuan.me/cs186/04-Sorting-and-Hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/04-Sorting-and-Hashing/</guid><description>Introduction # When dealing with disk operations, traditional sorting algorithms tend to create lots of random accesses and can be quite slow. We’ll explore a few strategies for creating optimized algorithms for sorting databases that work around our limited memory and buffer management abilities.
Relevant Materials # Note 6: Sorting Note 7: Hashing Discussion 4: Sorting Discussion 5: Hashing Single-Pass Streaming # Single-pass streaming is an approach for mapping inputs to their desired outputs while minimizing memory and disk usage.</description></item><item><title/><link>https://notes.bencuan.me/cs70/probability/concentration-inequalities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/probability/concentration-inequalities/</guid><description>Also see the Data 102 notes on this topic.
Markov&amp;rsquo;s Inequality: http://prob140.org/textbook/content/Chapter_18/04_Chi_Squared_Distributions.html
Chebyshev&amp;rsquo;s Inequality: http://prob140.org/textbook/content/Chapter_18/04_Chi_Squared_Distributions.html
Chernoff Bound: http://prob140.org/textbook/content/Chapter_19/04_Chernoff_Bound.html?highlight=chernoff</description></item><item><title/><link>https://notes.bencuan.me/data102/sampling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/sampling/</guid><description>Intro # In practice, getting the exact probability of an inference is not required as long as we get a rough estimate (80% chance is basically the same as 80.15%, etc.).
In order to cut down on the resources required to make inferences from a Bayes Net, we can use sampling techniques to approximate the true probability of a query.
Prior Sampling # For all $i$ in topological order , sample $X_i$ from the CPT of $P(X_i | parents(X_i))$.</description></item><item><title>Iterators and Joins</title><link>https://notes.bencuan.me/cs186/05-Iterators-and-Joins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/05-Iterators-and-Joins/</guid><description>Introduction # As you may have seen already, some SQL queries involve joining lots of tables together to get the data we need. However, that joining comes at a cost- every join multiplies the number of rows in the output by the number of rows in the table!
For this reason, it&amp;rsquo;s very important that we try to optimize the join operation as much as possible, such that we can minimize the amount of data to process.</description></item><item><title>Resource Sharing</title><link>https://notes.bencuan.me/cs168/resource-sharing-packet-and-circuit-switching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/resource-sharing-packet-and-circuit-switching/</guid><description>Statistical Multiplexing # On the internet, millions of packets going to different destinations must share the same routers and paths.
One way to handle this demand is statistical multiplexing- the concept of combining demands to share resources efficiently, rather than statically partitioning resources.
Some examples of statistical multiplexing:
processes sharing CPU cores (vs each process using 1 core) Cloud computing (vs each user has their own datacenter) public transit (vs each person drives a car) The peak of aggregate demand is far less than the aggregate of peak demands.</description></item><item><title/><link>https://notes.bencuan.me/cs70/probability/continuous-probability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/probability/continuous-probability/</guid><description> (Credit: Huiyi Zhang)
All of the continuous probability distributions are deeply connected. Above is a chart describing some of their relationships.
Below are some links:
Poisson Beta Exponential Normal Gamma Chi-Squared</description></item><item><title>Internet Organization</title><link>https://notes.bencuan.me/cs168/internet-organization-and-layers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/internet-organization-and-layers/</guid><description>Currently, five internet layers exist:
Application (L7), where code interfaces with the internet as an abstraction, Transport (L4), which can guarantee either reliable or unreliable data delivery, Network (L3), which delivers best-effort global packet delivery, Datalink (L2), which delivers best-effort local packet delivery, Physical (L1), which physically moves bits between locations. HIstorically, L5 (Session layer) and L6 (Presentation layer) existed, but have since been combined with L7 and L4.</description></item><item><title>Regression and GLMs</title><link>https://notes.bencuan.me/data102/regression-and-glms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/regression-and-glms/</guid><description>Posterior Predictive Distribution # Posterior Predictive Distribution: &amp;ldquo;if we saw some data, what future data might we expect?&amp;rdquo;
$P(x_{n+1}|x_1,\cdots,x_n)$ = $\int P(x_{n+1}|\theta)P(\theta|x_1,\cdots,x_n)d\theta$ $= E_{\theta|X}(P(x_{n+1}|\theta))$, which is an average with respect to the posterior. In practice, the posterior component is estimated.
Linear Regression # $$Y = X\beta + \epsilon$$ where $Y$ is a $n \times 1$ vector, $X$ is a $n \times d$ matrix,
$Y$ is unknown and fixed, $X$ is known and fixed, $\epsilon$ is unknown and random (sampled from i.</description></item><item><title>Relational Algebra</title><link>https://notes.bencuan.me/cs186/06-Relational-Algebra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/06-Relational-Algebra/</guid><description>Introduction # Relational algebra is a language that represents a logical query plan for translating SQL queries into underlying actions. This is useful because SQL queries don&amp;rsquo;t save information for the order in which operations are carried out. As you&amp;rsquo;ll see, several different ways of processing the same query could lead to the same result.
It represents how we perform operations on sets to achieve the desired result. In contrast, relational calculus represents the result (the what of a calculation).</description></item><item><title/><link>https://notes.bencuan.me/cs168/sockets-and-ports/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/sockets-and-ports/</guid><description>Network Ports # Switches and routers have physical ports where links connect to switches. The OS supports logical ports where applications connect to the operating system&amp;rsquo;s network stack.
Sockets # A socket is an OS mechanism that creates and manages logical ports. When an app wants access to the network, a socket is opened and associated with a port number. All incoming packets to that port number are then sent to the socket it&amp;rsquo;s associated with.</description></item><item><title/><link>https://notes.bencuan.me/cs70/probability/markov-chains/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/probability/markov-chains/</guid><description>Markov Chains are a type of stochastic process (a collection of random variables that evolves over time) that satisfy the Markov property (the future state $n+1$ only depends on the current state $n$, and not any of the past states).
Markov chains are often used to model transitions between discrete states.
http://prob140.org/textbook/content/Chapter_10/00_Markov_Chains.html</description></item><item><title/><link>https://notes.bencuan.me/data102/nonparametric-methods/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/nonparametric-methods/</guid><description>What does nonparametric mean? # Nonparametric methods make no assumptions about the distribution of the data or parameters; the null hypothesis is solely generated based on the data.
In some other contexts, the number of parameters in a nonparametric method is either infinite or grows with the number of data points.
Supposing the true state of the world is $\theta$ and our data is $x$, parametric/forward models attempt to make some assumptions about $\theta$ that make us most likely to see the data $x$.</description></item><item><title>Addressing</title><link>https://notes.bencuan.me/cs168/addressing-ip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/addressing-ip/</guid><description>How do we scale the ideas of routing and forwarding to the scale of the entire internet?
This is mainly resolved with the domain of addressing.
Early Addressing Schemes # In the early internet, each network had its own identifier, and each host within a network had its own identifier. Naturally, any host could be addressed using two numbers in the form networkID.hostID.
As a result of this hierarchical addressing scheme, each internal router only needs to store information about the hosts within the same network, as well as a gateway address to a border router connected to external networks.</description></item><item><title>Query Optimization</title><link>https://notes.bencuan.me/cs186/07-Query-Optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/07-Query-Optimization/</guid><description>Introduction # Query optimization is the bridge between a declarative language (like SQL, where you describe “what” you want) and an imperative language (like Java, which describes how the answer is actually computed). Here, we built the translator that converts SQL into logic that a computer can understand.
If you think about it, this can be really complicated- there&amp;rsquo;s lots of ways to execute a query (i.e. many equivalent relational algebra statements), and we have to somehow figure out which one is the best without executing any of them!</description></item><item><title/><link>https://notes.bencuan.me/cs70/probability/the-beta-family/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/probability/the-beta-family/</guid><description>The Beta distribution is a family of continuous distributions on [0,1] with two parameters (commonly known as $\alpha$ and $\beta$, but also $r$ and $s$).
Beta distributions are commonly used in situations where we want to continually update a prior distribution given new information.
The beta (1,1) distribution is identical to the uniform distribution. http://prob140.org/textbook/content/Chapter_21/00_The_Beta_and_the_Binomial.html</description></item><item><title/><link>https://notes.bencuan.me/data102/interpretability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/interpretability/</guid><description>What do we look for in predictions? # Accuracy: We want predictions to be close to the true values. Simplicity: We want the model to be easy to understand and trust. Interpretability: We want to be able to explain why the model behaved the way it did.
Components of interpretability # What is it?
transparency: understanding the model explanations: understanding the predictions When and why do we care?</description></item><item><title>Interdomain Routing (BGP)</title><link>https://notes.bencuan.me/cs168/interdomain-routing-bgp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/interdomain-routing-bgp/</guid><description>In [[intradomain routing]], we primarily focused on processes for intradomain routing- where switches discover paths within their own networks.
Now, we&amp;rsquo;ll discuss interdomain routing between many autonomous systems.
Autonomous Systems (AS) # As a review, an autonomous system is a domain that represents a network under a single administrative control. Every AS is assigned a unique ASN by ICANN.
A stub AS only sends and receives packets on behalf of its directly connected hosts.</description></item><item><title>Transactions and ACID</title><link>https://notes.bencuan.me/cs186/08-Transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/08-Transactions/</guid><description>What is a transaction? # Transactions are collections of operations that can be treated like a single unit. The primary reason why we need transactions is to obey the ACID properties:
Atomicity: either all operations happen, or none of them Consistency: database remains in a consistent state with its constraints (for example, primary keys will never be null) Isolation: it should appear as if we only run 1 transaction at a time (even if they’re actually run concurrently) Durability: once a transaction commits, it persists Transactions support two main operations:</description></item><item><title/><link>https://notes.bencuan.me/cs70/probability/conditional-expectation-and-variance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/probability/conditional-expectation-and-variance/</guid><description>Properties:
Conditional Expectation # $E(X|Y)$is the conditional expectation of $X$given $Y$
$E(X|Y=y)$is a fixed value, but $E(X|Y)$is a random variable (it is a function of $Y$) Iterated expectation: $E(E(X|Y)) = E(X)$ Additivity: $E(Y+Z | X) = E(Y|X) + E(Z|X)$ does not work on the right hand side: $E(Y | X+Z) \ne E(Y|X) + E(Y|Z)$ Linearity: $E(aX + b | Y) = aE(X|Y) + b$ Conditioning on the same variable: $E(g(S)T | S) = g(S)E(T|S)$ Conditional Variance # If $Var(Y)$is difficult to find directly, we can use the variance decomposition to condition the variance on another variable.</description></item><item><title/><link>https://notes.bencuan.me/data102/causality/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/causality/</guid><description>Prediction vs Causality # Prediction: using $X$ data, can we guess what $y$ will be?
Causation: does X cause y to change?
Affects decisions Typically established via randomized experiments Case Studies in Causality # Confounding Factor # A Martian comes to Earth and observes that people using umbrellas have a higher probability of getting wet than people who do not. They infer that using an umbrella causes people to get wet.</description></item><item><title>Parallel Query Processing</title><link>https://notes.bencuan.me/cs186/09-Parallel-Query-Processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/09-Parallel-Query-Processing/</guid><description>Relevant Materials # Note 15 Discussion 11 Parallelism # Parallelism helps us break down a big problem into small, independent chunks. The idea is that a lot of machines all working on the same problem at the same time will finish the problem more quickly.
There are two main metrics we want:
Speed-up: if we add more hardware, the same workload should be completed more quickly.</description></item><item><title/><link>https://notes.bencuan.me/data102/concentration-inequalities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/concentration-inequalities/</guid><description>The goal of concentration inequalities is to provide bounds on the probability of a random variable taking values in its tail (regions farthest away from the mean).
This is especially useful when we don&amp;rsquo;t know the distribution of a random variable, or we have a combination of other random variables (sample mean, quicksort, multi-arm bandit&amp;hellip;).
Markov&amp;rsquo;s Inequality # If $X$ is a non-negative random variable with expectation $\mu$, then $$P(X \ge t) \le \frac{\mu}{t}$$</description></item><item><title>Recovery</title><link>https://notes.bencuan.me/cs186/10-Recovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/10-Recovery/</guid><description>Introduction # Recovery is the process of making databases resilient to failure. Specifically, recovery enforces durability (a committed transaction remains persistent) and atomicity (either all of the operations in a transaction complete, or none of them).
Assumptions:
We use strict two-phase locking for concurrency control. Updates happen in-place: transactions that modify data overwrite entries in the database. Relevant Materials # Note 13 Discussion 9 Steal/No Force # No Steal Policy # Don’t allow buffer pool frames with uncommitted updates to be replaced or flushed to disk.</description></item><item><title>TCP</title><link>https://notes.bencuan.me/cs168/TCP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/TCP/</guid><description>The Transport Layer # The transport layer (L4) is built directly on top of the networking layer. Many different protocols exist on the transport layer, most notably TCP and UDP.
The goal of the transport layer is to bridge the gap between tne abstractions application designers want, and the abstractions that networks can easily support. By providing a common implementation, the transport layer makes development easier.
The main tasks of the transport layer include:</description></item><item><title/><link>https://notes.bencuan.me/cs168/reliability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/reliability/</guid><description>In general, the network is best-effort, meaning that packets are not guaranteed to be delivered successfully. How do we build reliability on top of an unreliable network?
Semantics of correct delivery # At the network layer (L3 and below), delivery is best-effort. No guarantees can be made. At the transport layer (L4), delivery is at-least-once. Packets should reach the end host, but may be duplicated. At the application layer (L7), delivery is exactly-once.</description></item><item><title/><link>https://notes.bencuan.me/data102/bandits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/bandits/</guid><description>Main idea: making repeated decisions based on feedback, factoring in the tradeoff between exploring new decisions or keeping existing good decisions
Multi-Armed Bandit Framework # The Multi-Armed bandit problem arises when the following are true:
We need to get the data as a part of the process Exploration/exploitation tradeoff (both have a cost) Stochastic: rewards are random Setup:
Selection rounds $1, \cdots, T$ Arms (choices) $1, \cdots, K$ $P_i$: reward distribution for arm $i$ $\mu_i$: mean reward for $P_i$ distribution At each round $t$, choose an arm $A_t$ such that a reward $X_t \sim P_{A_t}$ is procured Define pseudo-regret at time $T$ as $\bar R_t = \sum_{t=1}^T (\mu^* - \mu_{A_t})$ where $\mu^*$ is the best mean possible.</description></item><item><title>Distributed Transactions</title><link>https://notes.bencuan.me/cs186/11-Distributed-Transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/11-Distributed-Transactions/</guid><description>Introduction # In some situations (like in datacenters), the computation needed for transactions gets to be too great for a single computer to handle.
One solution for this is to build wide- connect a whole bunch of computers together, and have them all work on the same thing! However, this comes with its challenges.
One such challenge is how we can still preserve ACID properties of transactions when each computer is working independently.</description></item><item><title/><link>https://notes.bencuan.me/cs168/congestion-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/congestion-control/</guid><description>If the capacity of the output link is less than the capacity of the incoming links, then it is possible for too many packets to arrive at once, overloading the link.
Here&amp;rsquo;s a graph of the packet delay as a function of load, assuming that we use a simple queue:
Fundamentally, congestion control is a resource allocation problem. However, it is very complex because changing one link can have a global impact, and these impacts need to be accounted for by every router on every flow change.</description></item><item><title/><link>https://notes.bencuan.me/data102/Markov-Decision-Processes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/Markov-Decision-Processes/</guid><description>What is a Markov Decision Process? # A Markov Decision Process is a Markov model that solves nondeterministic search problems (where an action can result in multiple possible successor states).
A MDP is defined by:
A set of states $s$ A set of actions $a$ A transition model $T(s, a, s’)$ that represents the probability $P(s’ | s, a)$ - that the action $a$ taken at state $s$ will lead to a new state $s’$.</description></item><item><title>E-R Diagrams</title><link>https://notes.bencuan.me/cs186/12-ER-Diagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/12-ER-Diagrams/</guid><description>Introduction # Production databases have a lot of tables with complicated relationships. Entity Relationship (ER) Diagrams help us organize databases in a visual manner.
Steps in Database Design # Database design is a bit different from the rest of the content we&amp;rsquo;ve covered so far. In previous sections, we mostly learned how to use databases and write the algorithms that make it work efficiently&amp;ndash; but now, we need to ensure that the data itself is structured in a meaningful manner to take advantage of all those optimizations!</description></item><item><title/><link>https://notes.bencuan.me/cs168/dns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/dns/</guid><description>DNS (domain name system) was created as a solution to make IP addresses human-readable for users.
In the early days, DNS took the form of a standardized address book called hosts.txt maintained by Elizabeth Feinler at the Network Information Center. This included an IP address, user-friendly name, and properties such as supported protocols. Whenever someone wanted to look up a name, they would query for hosts.txt. However, this got troublesome due to increased burden on the NIC team, high bandwidth usage as the number of hosts increased, and having a single point of failure.</description></item><item><title/><link>https://notes.bencuan.me/data102/Reinforcement-Learning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/data102/Reinforcement-Learning/</guid><description>Introduction # Reinforcement Learning (RL) is an example of online planning, where agents have no prior knowledge of rewards or transitions and must explore an environment before using an estimated policy.
Model-based learning: attempts to estimate transition and reward functions with samples attained during exploration before solving MDP with estimates using value or policy iteration Model-free learning: attempts to estimate values/Q-values of states directly without construction a reward or transition model in MDP Passive reinforcement learning: agent is given a policy and learns the values of states under that policy.</description></item><item><title/><link>https://notes.bencuan.me/cs168/web/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/web/</guid><description>Origins # In 1989, Tim Berners-Lee set out to solve a problem: there was a lot of information being stored digitally, and no way to find or access much of it. He created &amp;ldquo;Information Management: A Proposal&amp;rdquo; in which the concept of the &amp;ldquo;web&amp;rdquo; was first established.
This proposal had several key parts:
not based on a hierarchy allows remote access across networks heterogeneity: different systems can access the same data non-centralization: ability for existing systems to be linked together without a central control access to existing data: ability to get data from existing databases to reduce overhead of adapting new system Why was this so successful?</description></item><item><title/><link>https://notes.bencuan.me/cs168/ethernet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/ethernet/</guid><description>Shared Media # In a radio network, nodes use a shared medium (the electromagnetic spectrum). As such, transmissions from different nodes might collide with one another, so we need a multiple access protocol to allocate the medium between users.
Some common approaches for doing this include:
Frequency Division Multiplexing: divide medium by frequency. This can be wasteful since frequencies are likely to be idle often. Time Division Multiplexing: divide medium by time.</description></item><item><title/><link>https://notes.bencuan.me/cs168/end-to-end-operation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/end-to-end-operation/</guid><description>Suppose we have the following scenario:
Host H1 boots up Fetches small file from H5 Goes idle Fetches two small files from H2 ![[/cs168/img/Pasted image 20221210190305.png]] Here&amp;rsquo;s what will happen:
DHCP to get configuration UDP Discover =&amp;gt; broadcast UDP Offer from H4 &amp;lt;- H1 UDP Request =&amp;gt; broadcast UDP ack &amp;lt;- H1 ARP for DNS server ARP request for H3 =&amp;gt; broadcast H3 ARP response &amp;lt;- unicast to H1 Resolve H5 UDP DNS request for H5.</description></item><item><title/><link>https://notes.bencuan.me/cs168/final-review/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs168/final-review/</guid><description>Part 1 # Original questions: final review part 1
1.1 # less aggressive than normal TCP.
Aggressiveness is determined by the throughput. Higher throughput = more aggressive.
Throughput can be calcuated by dividing the number of bytes over time (or, packets per RTT).
In a normal TCP implementation, the multiplier $M$ is $0.5$.
At full throughput (highest possible window size $W$ before loss occurs), the throughput is $W/RTT$. At minimum throughput during congestion avoidance (right after loss is detected), the throughput is $1/2 \times W/RTT$Q.</description></item><item><title/><link>https://notes.bencuan.me/cs61a/resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61a/resources/</guid><description>Here are some resources!
My Resources # Scheme Cheat Sheet # This cheat sheet was created in Fall 2021 and includes Scheme syntax bits, and correspondences to Python.
61A Scheme Cheat Sheet
Discussion and Lab Slides # These slides were created by me and presented during the Spring 2022 offering of CS61A.
Link Content Discussion 1 Expressions, values, statements, control, environment diagrams Discussion 2 Higher order functions Discussion 3 Recursion Discussion 4 Tree recursion, lists Discussion 5 Sequences, mutability, OOP Discussion 6 String representation, trees Discussion 7 Linked lists, iterators, generators Discussion 10 Scheme Discussion 11 Tail Recursion Discussion 12 Programs as Data Discussion 13 Regex, BNF Discussion 14 Some advice Lab 1 Python Syntax Lab 2 Higher order functions, lambdas Lab 4 Recursion, tree recursion Lab 5 List comprehensions, mutation Lab 6 OOP, inheritance Lab 7 Trees, linked lists Lab 8 Efficiency Lab 10 Scheme Lab 11 Interpreters Lab 12 Data Abstraction Lab 13 Regex Lab 14 Final review + tips Other Resources # These resources were created by other 61A TA&amp;rsquo;s throughout the years.</description></item><item><title/><link>https://notes.bencuan.me/cs70/discrete-math/propositional-logic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/propositional-logic/</guid><description>What are Propositions? # Propositions are anything that can be true or false. This could include:
Statements like &amp;ldquo;Birds can fly&amp;rdquo;. Well defined equations with no free variables like $1 + 1 = 3$. Propositions are not:
Variables like $x$ or $5$. Equations with free variables like $P(x) = y$. Statements that aren&amp;rsquo;t clearly true or false, like &amp;ldquo;I like trains.&amp;rdquo; Connectives # Simple propositions can be joined together to make complex statements.</description></item><item><title/><link>https://notes.bencuan.me/cs70/discrete-math/proofs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/proofs/</guid><description>Introduction # A proof is a set of logical deductions that can be used to show how something is true. This is powerful because proofs can often be very general, allowing a truth to be used in a whole bunch of cases that don&amp;rsquo;t individually need to be re-proven.
There are a number of common proof techniques (although these certainly aren&amp;rsquo;t exhaustive!) outlined below.
Direct Proofs # In direct proofs, we can use the definitions directly to show that something is true.</description></item><item><title/><link>https://notes.bencuan.me/cs70/discrete-math/stable-matching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/stable-matching/</guid><description>Introduction # The stable matching problem deals with how to match one group to another group while trying to maximize everyone&amp;rsquo;s &amp;lsquo;happiness&amp;rsquo;.
It works best when the two groups are distinct (nobody can be in both groups at once) and the orderings are complete (everyone in the other group has to show up in all orderings). Before we get to examples of when this might apply, I&amp;rsquo;ll throw out a few examples where we can&amp;rsquo;t use this algorithm so you don&amp;rsquo;t get any wrong ideas:</description></item><item><title/><link>https://notes.bencuan.me/cs70/discrete-math/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/graphs/</guid><description>[!info] Content Note
This is a second introduction to graphs that assumes you&amp;rsquo;ve at least seen them before. Take a look at the 61B version if you feel lost!
What&amp;rsquo;s a graph? # Formally, a graph is a set of vertices with a set of edges connecting them. A graph can be defined as $G = (V, E)$ where $V = {A, B, \cdots V_n}$ and $E = {{A, B}, {B, C} \cdots }$</description></item><item><title>Modular Arithmetic</title><link>https://notes.bencuan.me/cs70/discrete-math/modular-arithmetic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/modular-arithmetic/</guid><description>What is Modular Arithmetic? # Modular arithmetic is &amp;ldquo;clock math&amp;rdquo; - that is, when numbers wrap around back to 0 if they get too big. You could think about it like a remainder: $21 \pmod{10}$ for example can be read as &amp;ldquo;what is the remainder of 21 when it is divided by 10?&amp;rdquo; (it&amp;rsquo;s 1, by the way.)
This is an important concept in many aspects of computer science, namely cryptography and error correction among many others.</description></item><item><title>RSA Cryptography</title><link>https://notes.bencuan.me/cs70/discrete-math/rsa-cryptography/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/rsa-cryptography/</guid><description>Introduction # The internet is built upon the fact that stuff needs to go from point A to point B quickly, accurately, and securely. We&amp;rsquo;ll talk about the secure part of that now (the accurate part will be addressed soon!).
One of the ways we can make sure our top-secret messages can&amp;rsquo;t get intercepted is to encrypt them- mix them up to become incomprehensible using some secret code, then decrypt it at the other end.</description></item><item><title>Polynomials</title><link>https://notes.bencuan.me/cs70/discrete-math/polynomials/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/polynomials/</guid><description>Introduction # &amp;ldquo;I learned this in 4th grade&amp;rdquo;, you say, &amp;ldquo;and I already know how to do Taylor approximations and binomial expansions and get local minima&amp;hellip; what else is there to do?&amp;rdquo; (At least that was my first thought :stuck_out_tongue:)
Turns out, polynomials are super useful in the world of discrete math. Here, we&amp;rsquo;ll cover two applications in discrete space, which are secret sharing and error correction.
Important Properties # Gotta do some quick review first!</description></item><item><title>Countability</title><link>https://notes.bencuan.me/cs70/discrete-math/countability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/countability/</guid><description>How big is infinity? Are some infinities bigger than others? The $\infty$is a rather mind-boggling concept; the principles of countability will hopefully make some sense out of it.
Bijections # A bijection is a mapping between two sets such that there exists a unique pairing from a particular element of one set to another.
These ideas of existence and uniqueness can be formalized by considering some different types of maps:</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/graphs/</guid><description>Introduction # Graphs are simply a collection of vertices connected by edges. They&amp;rsquo;re very similar to trees, but are much more versatile and don&amp;rsquo;t require hierarchical relationships like trees do.
For most purposes, we will be working with simple graphs that follow two rules:
There are no loops (a connection of a node to itself). There are no parallel edges (two edges that connect the same two vertices).</description></item><item><title>Hashing and Hash Tables</title><link>https://notes.bencuan.me/cs61b/abstract-data-types/hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/hashing/</guid><description>Data Indexed Sets: Introduction # So far, we&amp;rsquo;ve explored a whole bunch of ways we can store items, but they aren&amp;rsquo;t really optimized for general searching. What if we could get searching in $\Theta(1)$ time??? Wouldn&amp;rsquo;t that be nice!
Let&amp;rsquo;s try something: putting all of our data in a massive array. Let&amp;rsquo;s say that we know all our data falls into the range from 0 to 10,000 and make an array of 10,000 length to hold stuff.</description></item><item><title>Union Find (Disjoint Sets)</title><link>https://notes.bencuan.me/cs61b/abstract-data-types/union-find-disjoint-sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/union-find-disjoint-sets/</guid><description>Union Find (Disjoint Sets) # [!info] Content Note
This is not a complete entry, because I feel like existing course materials already cover this in an extremely intuitive manner. See lab 14 for an guide on how to implement your own Union Find structure!
The Union Find data structure is a way of representing a bunch of nodes that are connected to each other in subsets. It&amp;rsquo;s used in Kruskal&amp;rsquo;s Algorithm among other things.</description></item><item><title>Sorting</title><link>https://notes.bencuan.me/cs61b/algorithms/sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/sorting/</guid><description>[!important] Sorting Guide
For more information about specific sorting algorithms covered in 61B, see my guide on sorting that covers all of the sorts in far greater detail 🙂
Why sort? # It makes searching for a specific value much faster (e.g. binary search). Typically, searching through an unsorted list requires a full scan ($\Theta(N)$​ runtime). It&amp;rsquo;s easy to see if two items in list are equal: just compare to see if any neighboring values are the same.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/comparables-and-comparators/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/comparables-and-comparators/</guid><description>What is it? # A Comparable is a generic type that allows standardized comparisons between objects.
In other words, anything that has a compareTo() method can be a Comparable!
Many Java libraries already use Comparable without you knowing! Some of the more well-known ones are Collection and String.
CompareTo can&amp;rsquo;t return anything you want! # There are some very specific properties CompareTo needs to have! Usually, we take them for granted but might forget about them when making our own.</description></item><item><title>A* Search</title><link>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/a-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/shortest-paths/a-search/</guid><description>[!info] Content Note
In order to understand A*, you&amp;rsquo;ll need to be comfortable Dijkstra&amp;rsquo;s Algorithm first!
A* Algorithm # The A* Search Algorithm is incredibly similar to Dijkstra&amp;rsquo;s Algorithm with one addition: a heuristic function.
This heuristic function calculates weights of a path from a vertex to a goal vertex. This way, we can help bias our algorithm in the right direction so that it doesn’t make a bunch of bad moves.</description></item><item><title>Computability</title><link>https://notes.bencuan.me/cs70/discrete-math/computability/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs70/discrete-math/computability/</guid><description>Computability is the study of a massively important question: do there exist any problems that are impossible for a computer to solve?
The Halting Problem # It turns out that the above question itself is impossible to solve: in other words, there cannot exist a program HALT which determines if a program can halt in finite time given a particular input.
This was originally proposed by Alan Turing- he proved the nonexistence by attempting to feed the Halting Problem into itself: if the Halting Problem doesn&amp;rsquo;t halt, then it is supposed to output an answer.</description></item><item><title>Minimax Algorithm</title><link>https://notes.bencuan.me/cs61b/algorithms/minimax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/minimax/</guid><description>Game Trees # The Minimax algorithm is often used for making AI&amp;rsquo;s for turn-based games. It relies on the use of a type of game tree, which maps out all of the possible moves that players can make.
In the tree, there are two types of nodes: maximizing nodes and minimizing nodes. The max-nodes represent you- you want to make your position as advantageous as possible (maximizing your score). The min-nodes represent your opponent- they want to make you do as poorly as possible (minimizing your score).</description></item><item><title/><link>https://notes.bencuan.me/cs61a/midterm-tips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61a/midterm-tips/</guid><description>Introduction # I get asked a lot about whether I have any advice for doing well on 61A exams, so I thought it would be nice to type some of it out. The following is my opinion/experience only, so feel free to ignore some or all of it if something else is more effective for you!
For a more complete guide, please visit https://cs61a.org/articles/studying/!
General Info # Midterm 1 is very early in the semester.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/balanced-search-structures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/balanced-search-structures/</guid><description>[!info] Content Note
Please read Binary Trees before continuing!
Balanced Binary Search Trees are an even more specific subcategory of binary trees that have an important property: they are always bushy.
B Trees (2-4 Trees) # The basic idea: Nodes can hold multiple values now! When nodes have too many values, we will split it.
A 2-4 tree is named such because each parent can have 2 to 4 children.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/heaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/heaps/</guid><description>What are Heaps? # A heap is a specific order of storing data, often in a list. Heaps are very similar to binary trees, but have some differences:
Unlike trees, heaps only care about the root node. Usually, the root node is either the largest or smallest value in the heap (corresponding with max-heaps and min-heaps), and we don&amp;rsquo;t care too much about the rest. Every element in the heap must be larger than all its children (in a max-heap) or smaller than all its children (in a min-heap).</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/tries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/binary-trees/tries/</guid><description>Main Ideas # A trie is a specific implementation of a set and is short for retrieval tree.
It only works on sets with a finite alphabet, like digits or ASCII characters, for example. The idea is that each node can act like an array containing all characters in the alphabet and we can just access the branches super fast by indexing into them!
Tries are fantastic for searching to see if a word is contained in a set.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/arrays/</guid><description>[!info] Content Note
This page assumes prior knowledge of Python lists from CS61A or equivalent.
Arrays are a very popular data structure that stores an indexed list of data.
Properties # Fixed length: after instantiation, the length of an array cannot be changed. Every value in array is the same type and holds the same amount of bits in memory. Zero-indexed. That means arr[0] returns the first value, and arr[arr.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/linked-lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/linked-lists/</guid><description>[!info] Content Note
This page assumes prior knowledge of linked lists from CS61A or equivalent. I&amp;rsquo;ll assume you have already worked with basic singly linked lists before.
The linked list is an extremely common recursive data structure that allows storage and access of an arbitrary amount of data.
Feature List of an Effective Linked List # Rebranding- represents Node as an individual object rather than having one monolithic List type.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/sets/</guid><description>[!warning] Warning
This page is incomplete. help make it better!
Basics # A Set stores a collection of values with no duplicates. Sets have no inherent order, so you can&amp;rsquo;t rely on expecting any value to come before any other value when iterating through them.
Some set functions include:
add(T x) contains(T x) size() ArraySet # An ArraySet is an array-based solution to a set implementation.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/abstract-data-types/collections/stacks-and-queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/abstract-data-types/collections/stacks-and-queues/</guid><description>Stacks and queues are two very common data structures used for a variety of applications from CPU processes to finding shortest paths using Dijkstra&amp;rsquo;s Algorithm. Fundamentally, they are very similar in structure and only differ by the order in which items are popped from them.
Pushing and Popping # Pushing # Adding an item to a stack or queue is called pushing. This will either put the item on the top of a stack or in the back of a queue.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/algorithms/searching/binary-search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/binary-search/</guid><description>Binary Search # Binary search is a way of finding a specific node in a tree. It only works on binary trees due to its helpful sorted property. It simply traverses the tree, moving left if the current node is too large or right if it is too small.
Binary search runs in $\Theta(\log(n))$ time for bushy trees, which is also the number of layers in a tree.
The Algorithm # public BST find(BST T, Key sk) { if (T == null) { return null; } if (sk.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/asymptotics/amortization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/asymptotics/amortization/</guid><description>Amortization # [!info] Content Note
Please read Asymptotic Analysis Basics first. If you don&amp;rsquo;t, none of this will make any sense!
Amortization means spreading out.
Sometimes, an operation takes different amounts of time for different values of $n$. Rather than having to report runtimes for each different case, we can instead average all of them out and report the amortized runtime.
This is especially good for functions where most actions have a low cost, but a few have a high cost.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/asymptotics/asymptotics-practice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/asymptotics/asymptotics-practice/</guid><description>Asymptotics Practice # [!info] Content Note
Make sure to review Asymptotic Analysis Basics before proceeding with these problems.
Introduction # Asymptotics is a very intuition-based concept that often doesn&amp;rsquo;t have a set algorithm for computing. The best way to get good at analyzing programs is to practice!
With that said, here are some problems of increasing difficulty for you to enjoy 😊
[!hint] Read before you do the problems!</description></item><item><title/><link>https://notes.bencuan.me/cs61b/misc-topics/exceptions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/misc-topics/exceptions/</guid><description>Exceptions # Basics # An exception occurs when something unintended occurs and the interpreter must exit.
While this might sound like a bad thing, we can often throw our own exceptions to handle known errors or edge cases more gracefully.
Exceptions in Java # In Java, there are two types of exceptions: checked and unchecked.
Checked exceptions are handled during compile time, and are included in the method declaration.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/misc-topics/modular-arithmetic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/misc-topics/modular-arithmetic/</guid><description>Modular Arithmetic and Bit Manipulation # [!warning] Content Note
Make sure you&amp;rsquo;re comfortable working with binary numbers (adding, subtracting, converting to decimal) before continuing.
Integer Types # This is an excerpt from the chart in Java Objects. Go there to review primitive types first!
Type Bits Signed Literals byte 8 yes 3, (int)17 short 16 yes None - must cast from int char 16 no &amp;lsquo;a&amp;rsquo;, &amp;lsquo;\n&amp;rsquo; int 32 yes 123, 0100 (octal), 0xff (hex) long 64 yes 123L, 0100L, 0xffL Signed Numbers # A type is signed if it can be positive or negative.</description></item><item><title/><link>https://notes.bencuan.me/cs61b/misc-topics/more-resources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/misc-topics/more-resources/</guid><description>More Resources # Here are some more cool things to look at!
Big O Cheat Sheet - complexities of sorting and common data structure operations Toptal Sorting Algorithm Animations - animations, pseudocode, and property summaries Josh Hug&amp;rsquo;s 61B Playlist - concise video lectures for most 61B topics Balanced Search Demos - play around with balanced search structures and see how they work</description></item><item><title>Breadth First Search (DFS)</title><link>https://notes.bencuan.me/cs61b/algorithms/searching/breadth-first-search-bfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/breadth-first-search-bfs/</guid><description>Breadth First Search (BFS), like Depth First Search (DFS), is a method of traversing a graph. BFS simply traverses in a different order, but otherwise is very similar to DFS.
The main difference is that BFS visits all children before any subgraphs. In a tree, we call this level order.
For the example tree above, a level order traversal would go in this order: D B F A C E G.</description></item><item><title>Chapter 1: OS Basics</title><link>https://notes.bencuan.me/cs162/Chapter-1-OS-Basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-1-OS-Basics/</guid><description>What is an operating system? # An operating system has three main roles:
Referee: The OS manages protection, isolation, and allocation of resources between processes. Illusionist: The OS provides an abstraction between hardware and user programs that provides an illusion ****of easy-to-access resources such as files and available processors. Glue: The OS provides common services, sharing, authorization, networking, and communication between processes and external devices. Q1.1. Consider a modern web browser (such as Chrome or Firefox) which plays a similar role to an operating system.</description></item><item><title>Chapter 2: Processes</title><link>https://notes.bencuan.me/cs162/Chapter-2-Processes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-2-Processes/</guid><description>The Process Abstraction # A process is an execution environment with restricted rights.
A process consists of:
An address space Thread(s) of control running in that address space System states associated with threads (files, etc) The process abstraction creates a tradeoff between protection and efficiency: communication is easier within processes, but harder between processes.
UNIX Process Management # Creating Processes: fork and exec # Forking # In UNIX-based systems, the primary way to create new processes is to fork an existing process.</description></item><item><title>Chapter 3: Threads</title><link>https://notes.bencuan.me/cs162/Chapter-3-Threads/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-3-Threads/</guid><description>The Thread Abstraction # A thread is a single unique context, or unit of concurrency, for execution that fully describes the program state. A thread consists of a program counter (PC), registers, execution flags, and a stack.
All threads in the same process share the same code, data, and file access, but each has its own register state and stack. Certain registers hold the context of the thread (such as the stack pointer, heap pointer, or frame pointer).</description></item><item><title>Chapter 4: I/O</title><link>https://notes.bencuan.me/cs162/Chapter-4-I-O/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-4-I-O/</guid><description>UNIX Abstraction: Everything is a File # A file is a named collection of data in a file system. In the POSIX (Portable Operating System Interface for UNIX) standard, every file includes data (a sequence of bytes) and metadata (such as size, modification time, owner, security, and access control).
Files are organized into directories, which are folders containing files and other directories. Directories employ hierarchical naming (/path/to/file.txt) to ensure that ever file has a unique identifier.</description></item><item><title>Chapter 5: Synchronization</title><link>https://notes.bencuan.me/cs162/Chapter-5-Synchronization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-5-Synchronization/</guid><description>Race Conditions and Locks # If two independent threads need to modify and read the same values, there could be multiple outputs depending on the order that the threads run in. How do we resolve this?
Synchronization deals with coordination among threads and their shared data
Mutual Exclusion: Only one thread does something at one time (excludes the other threads)
Subtype of synchronization Critical Section: code that only one thread can execute at once (consequence of mutual exclusion)</description></item><item><title>Chapter 6: S cheduling</title><link>https://notes.bencuan.me/cs162/Chapter-6-Scheduling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-6-Scheduling/</guid><description>Introduction # When multiple tasks need to be done on a single CPU, we need to figure out a way to distribute the work done by the CPU across all of the tasks.
At any point there are running, waiting, and blocked threads. A processor&amp;rsquo;s scheduling policy determines how and when threads transition between these states.
Scheduling Goals # There are three primary goals for an effective scheduling algorithm.</description></item><item><title>Chapter 7: Address Translation</title><link>https://notes.bencuan.me/cs162/Chapter-7-Address-Translation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-7-Address-Translation/</guid><description>Introduction # Every modern computer has physical memory inside of it, that might look something like this:
Physical RAM modules typically contain anywhere from 4 to 128GB of memory (well, at the time of writing). However, there are only a few sticks of RAM, and possibly hundreds of processes that need to access them at the same time!
This is where memory management comes in. This chapter will cover several methods to do so, such as address translation (virtual memory) and paging (breaking memory into chunks).</description></item><item><title>Chapter 8: Caching</title><link>https://notes.bencuan.me/cs162/Chapter-8-Caching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-8-Caching/</guid><description>Introduction # At this point, we&amp;rsquo;ve solved nearly all of the problems with base and bound memory translation. But there is one major problem left— all of this additional complexity adds lots of memory accesses, which might make things very inefficient! This is where caching comes in.
Since programs only care about a very small subset of the total information available, if we identify this subset and place it into more local memory, then we can efficiently perform most memory accesses.</description></item><item><title>Chapter 9: File Systems</title><link>https://notes.bencuan.me/cs162/Chapter-9-File-Systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Chapter-9-File-Systems/</guid><description>I/O # Drivers # A computer handles I/O on its end using several mechanisms:
The bus, a common set of communication wires, carries data transfer transactions between devices. A typical modern bus standard is PCI (Peripheral Component Interconnect), which is a parallel bus that can handle one transaction at a time. One major downside to this is that the bus speed must be set to the slowest connected device.</description></item><item><title>Contributing</title><link>https://notes.bencuan.me/contributing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/contributing/</guid><description>Thanks for your interest in contributing to my notes! There&amp;rsquo;s a lot of room for improvement, and I don&amp;rsquo;t have the time to fix everything. If there&amp;rsquo;s something that you&amp;rsquo;d like to add, please do so!
Making Requests # I use GitHub for issue tracking. Please make an issue before editing anything or creating a pull request, so I can comment on it before you start working on a feature.</description></item><item><title>Depth First Search (DFS)</title><link>https://notes.bencuan.me/cs61b/algorithms/searching/depth-first-search-dfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs61b/algorithms/searching/depth-first-search-dfs/</guid><description>Depth First Traversal # Before we move on to searching, let&amp;rsquo;s talk about traversing. Traversal is the act of visiting nodes in a specific order. This can be done either in trees or in graphs.
For trees in particular, there are three main ways to traverse.
The first way is inorder traversal, which visits all left children, then the node itself, then all right children. The end result should be that the nodes were visited in sorted order.</description></item><item><title>GDB Reference</title><link>https://notes.bencuan.me/cs162/Appendix-A-GDB-foobars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs162/Appendix-A-GDB-foobars/</guid><description>Run with args: r &amp;lt;args&amp;gt;
Breakpoint: b &amp;lt;n&amp;gt;
Conditional breakpoint: b &amp;lt;n&amp;gt; if &amp;lt;condition&amp;gt; or condition &amp;lt;n&amp;gt; &amp;lt;condition&amp;gt; on existing
Step into: step or s (si for assembly)
Step over: next or n (for assembly, ni)
See all registers: info registers (can also do info frame, info args, info locals)
View split mode: ctrl+x ctrl+a
Switch between code and assembly: layout asm, layout src. Ctrl+X A to exit split
View hex memory: x &amp;lt;name&amp;gt; or x/Nx &amp;lt;name&amp;gt; to view N bytes after name</description></item></channel></rss>