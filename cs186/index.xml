<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome to CS186! on</title><link>https://notes.bencuan.me/cs186/</link><description>Recent content in Welcome to CS186! on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/cs186/index.xml" rel="self" type="application/rss+xml"/><item><title>What is an I/O and why should I care?</title><link>https://notes.bencuan.me/cs186/io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/io/</guid><description>If you&amp;rsquo;re taking 186, you&amp;rsquo;ve probably heard or experienced some variation of the following:
This class has a lot of I/O counting on exams I/Os are weird, sometimes you can read like 5 things at the same time but it&amp;rsquo;s still one I/O for some reason I/O counting is tedious and boring and I will never do it after this class, so why do I need to do it?????? While I can&amp;rsquo;t guarantee that you&amp;rsquo;ll ever count I/Os after this class, my hope for this article is to justify why it&amp;rsquo;s necessary for understanding key database design concepts, and how the principles can be applied to real-world issues in query optimization.</description></item><item><title/><link>https://notes.bencuan.me/cs186/01-Disks-Buffers-Files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/01-Disks-Buffers-Files/</guid><description>Relevant Materials # Note 3 Discussion 2 Introduction # Now that we&amp;rsquo;ve taken a look at how humans can interface with databases using SQL, let&amp;rsquo;s jump all the way down to the bottom and lay the foundations for how we can go from individual bytes to a fully functional database!
Before reading this section, review the page What is an I/O and why should I care?</description></item><item><title/><link>https://notes.bencuan.me/cs186/02-B+-Trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/02-B+-Trees/</guid><description>Relevant Materials # Note 4 Discussion 3: view this for B+ tree algorithm walkthroughs! Introduction # B+ Trees are one type of index: a data structure that allows for quick lookups based on a particular key. They are very similar to binary trees, but can have more than two pointers and come with a variety of improvements.
What is an index exactly? # We can index a collection on any ordered subset of columns.</description></item><item><title/><link>https://notes.bencuan.me/cs186/03-Buffer-Management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/03-Buffer-Management/</guid><description>Introduction # So far, we&amp;rsquo;ve established the fact that the disk is slow, and memory is fast- and that one of the biggest challenges in database implementation is in minimizing the number of times we need to incur I/Os by transferring data in between disk and memory.
Since memory is limited, we need to figure out a clever way to re-use information once it&amp;rsquo;s read into memory, while still allowing new information to come in when needed.</description></item><item><title/><link>https://notes.bencuan.me/cs186/04-Sorting-and-Hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/04-Sorting-and-Hashing/</guid><description>When dealing with disk operations, traditional sorting algorithms tend to create lots of random accesses and can be quite slow. We’ll explore a few strategies for creating optimized algorithms for sorting databases.
Single-Pass Streaming # Single-pass streaming is an approach for mapping inputs to their desired outputs while minimizing memory and disk usage.
Main idea: There are two buffers (input and output). Continuously read from the input buffer and convert them into outputs to place in the output buffer.</description></item><item><title/><link>https://notes.bencuan.me/cs186/05-Iterators-and-Joins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/05-Iterators-and-Joins/</guid><description>Iterators and Joins # Cost Notation # Used to analyze the size of a database.
$R$ is a table.
$[R]$ is the number of pages needed to store $R$
$p_R$ is the number of records per page of $R$.
$|R|$ is the cardinality of $R$, or the number of records.
$|R| = p_R \times [R]$ Simple Join # Intuitively, joining two tables is essentially a double for loop over the records in each table:</description></item><item><title/><link>https://notes.bencuan.me/cs186/06-Relational-Algebra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/06-Relational-Algebra/</guid><description>Relational Algebra # Relational algebra is a language that represents a logical query plan for translating SQL queries into underlying actions.
perform operations on sets (the “how”) operational description of transformations Related to relational calculus (which describes the result of a computation: the “what”) by Codd’s Theorem: everything that can be represented with relational calculus can be equivalently represented in relational algebra Operators # Unary Operators # Unary operators work on a single relation.</description></item><item><title/><link>https://notes.bencuan.me/cs186/07-Query-Optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/07-Query-Optimization/</guid><description>Query Optimization # Query optimization is the bridge between a declarative language (like SQL, where you describe “what” you want) and an imperative language (like Java, which describes how the answer is actually computed).
System R Optimizers # The query parser first checks for correctness and authorization (user permissions to access the table). It then generates a parse tree out of the query. This step is usually fairly straightforward.</description></item><item><title/><link>https://notes.bencuan.me/cs186/08-Transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/08-Transactions/</guid><description>Transactions # Transactions are collections of operations that can be treated like a single unit.
ACID and Concurrency # We want all transactions to obey ACID:
Atomicity: either all operations happen, or none of them Consistency: database remains in a consistent state with its constraints Isolation: it should appear as if we only run 1 transaction at a time (even if they’re actually run concurrently) Durability: once a transaction commits, it persists Transaction operations:</description></item><item><title/><link>https://notes.bencuan.me/cs186/09-Parallel-Query-Processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/09-Parallel-Query-Processing/</guid><description>Parallel Query Processing # Parallelism helps us break down a big problem into small, independent chunks. The idea is that a lot of machines all working on the same problem at the same time will finish the problem more quickly.
There are two main metrics we want:
Speed-up: if we add more hardware, the same workload should be completed more quickly. Scale-up: if the workload increases, we should be able to add a corresponding amount of hardware to make the problem be processed with the same amount of time as before.</description></item><item><title/><link>https://notes.bencuan.me/cs186/10-Recovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/10-Recovery/</guid><description>Recovery # Recovery is the process of making databases resilient to failure. Specifically, recovery enforces durability (a committed transaction remains persistent) and atomicity (either all of the operations in a transaction complete, or none of them).
Assumptions:
We use strict two-phase locking for concurrency control. Updates happen in-place: transactions that modify data overwrite entries in the database. Steal/No Force # No Steal Policy # Don’t allow buffer pool frames with uncommitted updates to be replaced or flushed to disk.</description></item><item><title/><link>https://notes.bencuan.me/cs186/11-Distributed-Transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/11-Distributed-Transactions/</guid><description>Distributed Transactions # If
2 Phase Commit # Phase 1: voting
Coordinator asks participants to vote by sending a PREPARE message to all participants. Participants send VOTE YES or VOTE NO to coordinator. Participants log and flush either a PREPARE or ABORT record to the log, keeping track of the coordinator ID. After the coordinator receives a message from all participants, the coordinator logs and flushes either a COMMIT or ABORT record to log Phase 2: results</description></item><item><title/><link>https://notes.bencuan.me/cs186/12-ER-Diagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/12-ER-Diagrams/</guid><description>ER Diagrams # Production databases have a lot of tables with complicated relationships. Entity Relationship (ER) Diagrams help us organize databases in a visual manner.
Steps in Database Design # Requirement Analysis: what do users need the database to do? Conceptual Design (ER Model): highly level description of DB schemas Logical Design: translate ER model into DBMS data model Schema Refinement: consistency, normalization Physical Design: indices, disk layout Security Design: who accesses what, and how Data Models # A data model is a collection of concepts for describing data.</description></item><item><title>SQL Basics</title><link>https://notes.bencuan.me/cs186/00-SQL-Basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/00-SQL-Basics/</guid><description>Relevant Materials # Note 1 Note 2 Discussion 1 What is SQL? # Structured Query Language (/ˈsiːkwəl/) is a highly standardized syntax for performing operations on a database.
Terminology # SQL databases are a set of named relations, or tables, that describe the relationship between attributes. You can think of attributes as the columns of the table, and each record (also known as a tuple) being one row in the table.</description></item></channel></rss>