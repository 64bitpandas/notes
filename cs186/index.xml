<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome to CS186! on</title><link>https://notes.bencuan.me/cs186/</link><description>Recent content in Welcome to CS186! on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/cs186/index.xml" rel="self" type="application/rss+xml"/><item><title>What is an I/O and why should I care?</title><link>https://notes.bencuan.me/cs186/io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/io/</guid><description>If you&amp;rsquo;re taking 186, you&amp;rsquo;ve probably heard or experienced some variation of the following:
This class has a lot of I/O counting on exams I/Os are weird, sometimes you can read like 5 things at the same time but it&amp;rsquo;s still one I/O for some reason I/O counting is tedious and boring and I will never do it after this class, so why do I need to do it?????? While I can&amp;rsquo;t guarantee that you&amp;rsquo;ll ever count I/Os after this class, my hope for this article is to justify why it&amp;rsquo;s necessary for understanding key database design concepts, and how the principles can be applied to real-world issues in query optimization.</description></item><item><title/><link>https://notes.bencuan.me/cs186/01-Disks-Buffers-Files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/01-Disks-Buffers-Files/</guid><description>Relevant Materials # Note 3 Discussion 2 Introduction # Now that we&amp;rsquo;ve taken a look at how humans can interface with databases using SQL, let&amp;rsquo;s jump all the way down to the bottom and lay the foundations for how we can go from individual bytes to a fully functional database!
Before reading this section, review the page What is an I/O and why should I care?</description></item><item><title/><link>https://notes.bencuan.me/cs186/02-B+-Trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/02-B+-Trees/</guid><description>Relevant Materials # Note 4 Discussion 3: view this for B+ tree algorithm walkthroughs! Introduction # B+ Trees are one type of index: a data structure that allows for quick lookups based on a particular key. They are very similar to binary trees, but can have more than two pointers and come with a variety of improvements.
What is an index exactly? # We can index a collection on any ordered subset of columns.</description></item><item><title/><link>https://notes.bencuan.me/cs186/03-Buffer-Management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/03-Buffer-Management/</guid><description>Introduction # So far, we&amp;rsquo;ve established the fact that the disk is slow, and memory is fast- and that one of the biggest challenges in database implementation is in minimizing the number of times we need to incur I/Os by transferring data in between disk and memory.
Since memory is limited, we need to figure out a clever way to re-use information once it&amp;rsquo;s read into memory, while still allowing new information to come in when needed.</description></item><item><title/><link>https://notes.bencuan.me/cs186/04-Sorting-and-Hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/04-Sorting-and-Hashing/</guid><description>Introduction # When dealing with disk operations, traditional sorting algorithms tend to create lots of random accesses and can be quite slow. We’ll explore a few strategies for creating optimized algorithms for sorting databases that work around our limited memory and buffer management abilities.
Single-Pass Streaming # Single-pass streaming is an approach for mapping inputs to their desired outputs while minimizing memory and disk usage. We will see this principle being used for many algorithms in this course.</description></item><item><title/><link>https://notes.bencuan.me/cs186/05-Iterators-and-Joins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/05-Iterators-and-Joins/</guid><description>Introduction # As you may have seen already, some SQL queries involve joining lots of tables together to get the data we need. However, that joining comes at a cost- every join multiplies the number of rows in the output by the number of rows in the table!
For this reason, it&amp;rsquo;s very important that we try to optimize the join operation as much as possible, such that we can minimize the amount of data to process.</description></item><item><title/><link>https://notes.bencuan.me/cs186/06-Relational-Algebra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/06-Relational-Algebra/</guid><description>Introduction # Relational algebra is a language that represents a logical query plan for translating SQL queries into underlying actions. This is useful because SQL queries don&amp;rsquo;t save information for the order in which operations are carried out. As you&amp;rsquo;ll see, several different ways of processing the same query could lead to the same result.
It represents how we perform operations on sets to achieve the desired result. In contrast, relational calculus represents the result (the what of a calculation).</description></item><item><title/><link>https://notes.bencuan.me/cs186/07-Query-Optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/07-Query-Optimization/</guid><description>Introduction # Query optimization is the bridge between a declarative language (like SQL, where you describe “what” you want) and an imperative language (like Java, which describes how the answer is actually computed).
System R Optimizers # The query parser first checks for correctness and authorization (user permissions to access the table). It then generates a parse tree out of the query. This step is usually fairly straightforward.</description></item><item><title/><link>https://notes.bencuan.me/cs186/08-Transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/08-Transactions/</guid><description>Transactions # Transactions are collections of operations that can be treated like a single unit.
ACID and Concurrency # We want all transactions to obey ACID:
Atomicity: either all operations happen, or none of them Consistency: database remains in a consistent state with its constraints Isolation: it should appear as if we only run 1 transaction at a time (even if they’re actually run concurrently) Durability: once a transaction commits, it persists Transaction operations:</description></item><item><title/><link>https://notes.bencuan.me/cs186/09-Parallel-Query-Processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/09-Parallel-Query-Processing/</guid><description>Parallel Query Processing # Parallelism helps us break down a big problem into small, independent chunks. The idea is that a lot of machines all working on the same problem at the same time will finish the problem more quickly.
There are two main metrics we want:
Speed-up: if we add more hardware, the same workload should be completed more quickly. Scale-up: if the workload increases, we should be able to add a corresponding amount of hardware to make the problem be processed with the same amount of time as before.</description></item><item><title/><link>https://notes.bencuan.me/cs186/10-Recovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/10-Recovery/</guid><description>Recovery # Recovery is the process of making databases resilient to failure. Specifically, recovery enforces durability (a committed transaction remains persistent) and atomicity (either all of the operations in a transaction complete, or none of them).
Assumptions:
We use strict two-phase locking for concurrency control. Updates happen in-place: transactions that modify data overwrite entries in the database. Steal/No Force # No Steal Policy # Don’t allow buffer pool frames with uncommitted updates to be replaced or flushed to disk.</description></item><item><title/><link>https://notes.bencuan.me/cs186/11-Distributed-Transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/11-Distributed-Transactions/</guid><description>Distributed Transactions # If
2 Phase Commit # Phase 1: voting
Coordinator asks participants to vote by sending a PREPARE message to all participants. Participants send VOTE YES or VOTE NO to coordinator. Participants log and flush either a PREPARE or ABORT record to the log, keeping track of the coordinator ID. After the coordinator receives a message from all participants, the coordinator logs and flushes either a COMMIT or ABORT record to log Phase 2: results</description></item><item><title/><link>https://notes.bencuan.me/cs186/12-ER-Diagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/12-ER-Diagrams/</guid><description>ER Diagrams # Production databases have a lot of tables with complicated relationships. Entity Relationship (ER) Diagrams help us organize databases in a visual manner.
Steps in Database Design # Requirement Analysis: what do users need the database to do? Conceptual Design (ER Model): highly level description of DB schemas Logical Design: translate ER model into DBMS data model Schema Refinement: consistency, normalization Physical Design: indices, disk layout Security Design: who accesses what, and how Data Models # A data model is a collection of concepts for describing data.</description></item><item><title>SQL Basics</title><link>https://notes.bencuan.me/cs186/00-SQL-Basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/00-SQL-Basics/</guid><description>Relevant Materials # Note 1 Note 2 Discussion 1 What is SQL? # Structured Query Language (/ˈsiːkwəl/) is a highly standardized syntax for performing operations on a database.
Terminology # SQL databases are a set of named relations, or tables, that describe the relationship between attributes. You can think of attributes as the columns of the table, and each record (also known as a tuple) being one row in the table.</description></item></channel></rss>