<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome to CS186! on</title><link>https://notes.bencuan.me/cs186/</link><description>Recent content in Welcome to CS186! on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://notes.bencuan.me/cs186/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://notes.bencuan.me/cs186/01-Disks-Buffers-Files/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/01-Disks-Buffers-Files/</guid><description>Disks, Buffers, Files # Devices # Hierarchy:
Page = Block = atomic unit for disk IO (can’t write a fractional page)
Sequential runs are assumed to be fast.
HDD # Hard drives are magnetic disks that contain tracks of data around a cylinder.
HDD&amp;rsquo;s are generally good for sequential reading, but bad for random reads.
Disk Latency = Queueing Time + Controller Time + Seek Time + Rotation Time + Transfer Time</description></item><item><title/><link>https://notes.bencuan.me/cs186/02-Cost-Analysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/02-Cost-Analysis/</guid><description>Cost Analysis # In order to make efficient queries, we need a measure of how good or fast a query is. Knowing that queries operate on records, which are stored on pages in a file on disk, we can use the following cost model for analysis:
$B$ = number of data blocks in file $R$ = number of records per block $D$ = average time to read or write disk block For analysis, we will use the following assumptions:</description></item><item><title/><link>https://notes.bencuan.me/cs186/03-B+-Trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/03-B+-Trees/</guid><description>B+ Trees # The Representation # Main idea: a search tree with a high branch factor. (Lower depth = faster runtime!)
Recursively index the key file such that: Great than or equal to index: Go to the right Less than the index: Go to the left All entries within each node are sorted.
Occupancy Invariant # The order of the tree, $d$, is defined such that each interior node is at least partially full:</description></item><item><title/><link>https://notes.bencuan.me/cs186/04-Sorting-and-Hashing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/04-Sorting-and-Hashing/</guid><description>Sorting and Hashing # When dealing with disk operations, traditional sorting algorithms tend to create lots of random accesses and can be quite slow. We’ll explore a few strategies for creating optimized algorithms for sorting databases.
Single-Pass Streaming # Single-pass streaming is an approach for mapping inputs to their desired outputs while minimizing memory and disk usage.
Main idea: There are two buffers (input and output). Continuously read from the input buffer and convert them into outputs to place in the output buffer.</description></item><item><title/><link>https://notes.bencuan.me/cs186/05-Iterators-and-Joins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/05-Iterators-and-Joins/</guid><description>Iterators and Joins # Cost Notation # Used to analyze the size of a database.
$R$ is a table.
$[R]$ is the number of pages needed to store $R$
$p_R$ is the number of records per page of $R$.
$|R|$ is the cardinality of $R$, or the number of records.
$|R| = p_R \times [R]$ Simple Join # Intuitively, joining two tables is essentially a double for loop over the records in each table:</description></item><item><title/><link>https://notes.bencuan.me/cs186/06-Relational-Algebra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/06-Relational-Algebra/</guid><description>Relational Algebra # Relational algebra is a language that represents a logical query plan for translating SQL queries into underlying actions.
perform operations on sets (the “how”) operational description of transformations Related to relational calculus (which describes the result of a computation: the “what”) by Codd’s Theorem: everything that can be represented with relational calculus can be equivalently represented in relational algebra Operators # Unary Operators # Unary operators work on a single relation.</description></item><item><title/><link>https://notes.bencuan.me/cs186/07-Query-Optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/07-Query-Optimization/</guid><description>Query Optimization # Query optimization is the bridge between a declarative language (like SQL, where you describe “what” you want) and an imperative language (like Java, which describes how the answer is actually computed).
System R Optimizers # The query parser first checks for correctness and authorization (user permissions to access the table). It then generates a parse tree out of the query. This step is usually fairly straightforward.</description></item><item><title/><link>https://notes.bencuan.me/cs186/08-Transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/08-Transactions/</guid><description>Transactions # Transactions are collections of operations that can be treated like a single unit.
ACID and Concurrency # We want all transactions to obey ACID:
Atomicity: either all operations happen, or none of them Consistency: database remains in a consistent state with its constraints Isolation: it should appear as if we only run 1 transaction at a time (even if they’re actually run concurrently) Durability: once a transaction commits, it persists Transaction operations:</description></item><item><title/><link>https://notes.bencuan.me/cs186/09-Parallel-Query-Processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/09-Parallel-Query-Processing/</guid><description>Parallel Query Processing # Parallelism helps us break down a big problem into small, independent chunks. The idea is that a lot of machines all working on the same problem at the same time will finish the problem more quickly.
There are two main metrics we want:
Speed-up: if we add more hardware, the same workload should be completed more quickly. Scale-up: if the workload increases, we should be able to add a corresponding amount of hardware to make the problem be processed with the same amount of time as before.</description></item><item><title/><link>https://notes.bencuan.me/cs186/10-Recovery/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/10-Recovery/</guid><description>Recovery # Recovery is the process of making databases resilient to failure. Specifically, recovery enforces durability (a committed transaction remains persistent) and atomicity (either all of the operations in a transaction complete, or none of them).
Assumptions:
We use strict two-phase locking for concurrency control. Updates happen in-place: transactions that modify data overwrite entries in the database. Steal/No Force # No Steal Policy # Don’t allow buffer pool frames with uncommitted updates to be replaced or flushed to disk.</description></item><item><title/><link>https://notes.bencuan.me/cs186/11-Distributed-Transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/11-Distributed-Transactions/</guid><description>Distributed Transactions # If
2 Phase Commit # Phase 1: voting
Coordinator asks participants to vote by sending a PREPARE message to all participants. Participants send VOTE YES or VOTE NO to coordinator. Participants log and flush either a PREPARE or ABORT record to the log, keeping track of the coordinator ID. After the coordinator receives a message from all participants, the coordinator logs and flushes either a COMMIT or ABORT record to log Phase 2: results</description></item><item><title/><link>https://notes.bencuan.me/cs186/12-ER-Diagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/12-ER-Diagrams/</guid><description>ER Diagrams # Production databases have a lot of tables with complicated relationships. Entity Relationship (ER) Diagrams help us organize databases in a visual manner.
Steps in Database Design # Requirement Analysis: what do users need the database to do? Conceptual Design (ER Model): highly level description of DB schemas Logical Design: translate ER model into DBMS data model Schema Refinement: consistency, normalization Physical Design: indices, disk layout Security Design: who accesses what, and how Data Models # A data model is a collection of concepts for describing data.</description></item><item><title/><link>https://notes.bencuan.me/cs186/13-Extras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/13-Extras/</guid><description>Extras # Databases at Uber # Postgres # Postgres is a popular open-source SQL relational DBMS that supports:
ACID transactions B-tree with indices Query optimization Parallelization Write-ahead logging Replication PostGIS geospatial support Some properties of Postgres:
Tuples are immutable, so we need to create a new version of a row every time we update it. All rows contain a version ID and a pointer the previous version.</description></item><item><title>SQL Basics</title><link>https://notes.bencuan.me/cs186/00-SQL-Basics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://notes.bencuan.me/cs186/00-SQL-Basics/</guid><description>Relational Terminology # Database: a set of named relations Relation: a table Schema: description (metadata) Fixed, with unique attribute names and atomic types (integers, text, etc.) Instance: the set of data that satisfies the schema Often changes, and can contain a multiset of tuples Attribute (column): a field Tuple (row): one record SQL Introduction # SQL is a relational database language that consists of two sub-languages:</description></item></channel></rss>